<html>
  <head>
    <meta charset="utf-8">
    <meta http-eqiv="Content-Type" content="text/html; charset=utf-8">
    <link rel="stylesheet" type="text/css" href="../lib/style.css">
    <title>Sagittarius Users' Reference</title>
  </head>
  <body>
    <p node-type="paragraph" class="navigation-container">
      <a href="./section62.html">(sagittarius control) - control library</a>
      <a href="../sagittarius-online-ref.html">Top</a>
      <a href="./section64.html">(sagittarius filewatch) - Monitoring filesystem</a>
    </p>
    <section node-type="section">
      <h2 node-type="header-2">
        <a name="lib.sagittarius.ffi">(sagittarius ffi) - Foreign Function Interface</a>
      </h2>
      <div node-type="define" class="define">
        <span>Library</span>
        <a name="(sagittarius ffi)_98">
          <span>(sagittarius ffi)</span>
        </a>
      </div>
      <p node-type="paragraph">This library provides FFI (Foreign Function Interface) procedures. The
library is constructed on
<a href="http://sourceware.org/libffi/">libffi</a>.</p>
      <p node-type="paragraph">This library makes user to be able to re-use existing useful C library. However
it might cause SEGV or unexpected behaviours. It is users responsibility to
avoid those errors.</p>
      <p node-type="paragraph">Following is the simple example to use;</p>
      <pre lang="c" node-type="block"><code>/* C file, must be compiled as a shared library and named 'my-quick-sort.so' */
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#ifdef _MSC_VER
# define EXPORT __declspec(dllexport)
#else
# define EXPORT
#endif

static void quicksort_(uintptr_t base,const size_t num,const size_t size,
		       void *temp,int (*compare)(const void *,const void *))
{
  size_t pivot = 0,first2last = 0,last2first = num-1;
  while(pivot+1 != num &amp;&amp; !compare(base+size*pivot,base+size*(pivot+1))){
    pivot++;
  }
  if(pivot+1 == num){
    return;
  }
  if(0 &gt; compare(base+size*pivot,base+size*(pivot+1))){
    pivot++;
  }
  while(first2last &lt; last2first){
    while(0 &lt; compare(base+size*pivot,base+size*first2last)
	  &amp;&amp; first2last != num-1){
      first2last++;
    }
    while(0 &gt;= compare(base+size*pivot,base+size*last2first)
	  &amp;&amp; last2first){
      last2first--;
    }
    if(first2last &lt; last2first){
      if(pivot == first2last || pivot == last2first){
	pivot = pivot^last2first^first2last;
      }
      memcpy(temp,base+size*first2last,size);
      memcpy(base+size*first2last,base+size*last2first,size);
      memcpy(base+size*last2first,temp,size);
    }
  }
  quicksort_(base,first2last,size,temp,compare);
  quicksort_(base+size*first2last,num-first2last,size,temp,compare);
}

EXPORT int quicksort(void *base, const size_t num, const size_t size,
	      int (*compare)(const void *, const void *))
{
  void *temp = malloc(size);
  if(!temp){
    return -1;
  }
  quicksort_((uintptr_t)base,num,size,temp,compare);
  free(temp);
  return 0;
}
</code></pre>
      <div node-type="block" class="codeblock">
        <pre lang="scheme" node-type="block"><code>;; Scheme file
;; load shared library (on Windows the extension might be '.dll')
;; On Unix like environment, the shared library must be full path or
;; located in the same directory as the script.
;; On Windows it can be on PATH environment variable as well.
(define so-library (open-shared-library "my-quick-sort.so"))
(define quick-sort 
  (c-function so-library ;; shared library
              void       ;; return type
              quicksort  ;; exported symbol
              ;; argument types
              ;; if you need pass a callback procedure, 'callback' mark needs to
              ;; be passed to the arguments list
              (void* size_t size_t callback)))

(let ((array (u8-list-&gt;bytevector '(9 3 7 5 2 6 1 4 8)))
      ;; callback procedure
      (compare (c-callback int           ;; return type
                           (void* void*) ;; argument types
                           (lambda (a b)
                             (- (pointer-ref-c-uint8 x 0)
                                (pointer-ref-c-uint8 y 0))))))
  ;; call c function. all loaded c functions are treated the same as
  ;; usual procedures.
  (quick-sort array (bytevector-length array) 1 compare)
  ;; release callback procedure.
  ;; NOTE: callback won't be GCed so users need to release it manually
  (free-c-callback compare)
  array)

;; Close shared library.
(close-shared-library so-library)
</code></pre>
        <span />
        <span>#vu8(1 2 3 4 5 6 7 8 9)</span>
      </div>
      <p node-type="paragraph" />
      <p node-type="paragraph">The document describes higher APIs to lower APIs.</p>
      <section node-type="section">
        <h3 node-type="header-3">
          <a name="Shared-library--operations">Shared library  operations</a>
        </h3>
        <div node-type="define" class="define">
          <span>Function</span>
          <a name="open-shared-library_55">
            <span>open-shared-library</span>
            <span>
              <i node-type="i">file</i>
            </span>
            <span>
              <i node-type="i">:optional</i>
            </span>
            <span>
              <i node-type="i">(raise</i>
            </span>
            <span>
              <i node-type="i">#f)</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph"><i node-type="i">file</i> must be a string.</p>
        <p node-type="paragraph">Opens given <i node-type="i">file</i> shared library and returns its pointer.</p>
        <p node-type="paragraph">The internal process of <code node-type="code">open-shared-library</code> is depending on the
platform, for example if your platform is POSIX envirionment then it will use
<code node-type="code">dlopen</code>. So the resolving the <i node-type="i">file</i> depends on it. If you know the
absolute path of the shared library, then it's always better to use it.</p>
        <p node-type="paragraph">If then internal process of the procedure failed and <i node-type="i">raise</i> is #f then it
returns NULL pointer, if <i node-type="i">raise</i> is #t then it raises an error.</p>
        <div node-type="define" class="define">
          <span>Function</span>
          <a name="close-shared-library_112">
            <span>close-shared-library</span>
            <span>
              <i node-type="i">pointer</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph">Closes given shared library pointer and returns unspecified value.</p>
        <p node-type="paragraph">If the given pointer does not indicate proper shared library, the behaviour
is platform dependent. It might cause SEGV.</p>
        <div node-type="define" class="define">
          <span>Function</span>
          <a name="shared-object-suffix_72">
            <span>shared-object-suffix</span>
          </a>
        </div>
        <p node-type="paragraph">Returns platform specific shared library extension as a string value.
eg. <code node-type="code">".dll"</code> in Windows, <code node-type="code">".so"</code> in Linux or Unix.</p>
      </section>
      <section node-type="section">
        <h3 node-type="header-3">
          <a name="Creating-C-functions">Creating C functions</a>
        </h3>
        <p node-type="paragraph">This section describes more details to create a corresponding C functions.</p>
        <div node-type="define" class="define">
          <span>Macro</span>
          <a name="c-function_2">
            <span>c-function</span>
            <span>
              <i node-type="i">shared-library</i>
            </span>
            <span>
              <i node-type="i">return-type</i>
            </span>
            <span>
              <i node-type="i">name</i>
            </span>
            <span>
              <i node-type="i">(argument-types</i>
            </span>
            <span>
              <i node-type="i">...</i>
            </span>
            <span>
              <i node-type="i">)</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph">Creates a c-function object and returns a Scheme procedure.</p>
        <p node-type="paragraph"><i node-type="i">shared-library</i> must be opened shared-library.</p>
        <p node-type="paragraph"><i node-type="i">return-type</i> must be one of the followings;</p>
        <pre lang="scheme" node-type="block"><code>  void 
  bool  char
  short int long long-long
  unsigned-short unsigned-int unsigned-long unsigned-long-long
  intptr_t uintptr_t
  float double
  void* char* wchar_t*
  int8_t  int16_t  int32_t  int64_t
  uint8_t uint16_t uint32_t uint64_t
</code></pre>
        <p node-type="paragraph">The return value will be converted corresponding Scheme value. Following
describes the conversion;</p>
        <dl node-type="dlist">
          <dt>
            <code node-type="code">bool</code>
          </dt>
          <dd>
            <p node-type="paragraph">Scheme boolean</p>
          </dd>
          <dt>
            <code node-type="code">char*</code>
          </dt>
          <dd>
            <p node-type="paragraph">Scheme string from UTF-8</p>
          </dd>
          <dt>
            <code node-type="code">wchar_t*</code>
          </dt>
          <dd>
            <p node-type="paragraph">Scheme string from UTF-16 (Windows) or UTF-32.</p>
          </dd>
          <dt>
            <code node-type="code">char</code>
          </dt>
          <dt>
            <code node-type="code">short int long long-long</code>
          </dt>
          <dt>
            <code node-type="code">unsigned-short unsigned-int unsigned-long unsigned-long-long</code>
          </dt>
          <dt>
            <code node-type="code">intptr_t uintptr_t</code>
          </dt>
          <dt>
            <code node-type="code">int8_t  int16_t  int32_t  int64_t</code>
          </dt>
          <dt>
            <code node-type="code">uint8_t uint16_t uint32_t uint64_t</code>
          </dt>
          <dd>
            <p node-type="paragraph">Scheme integer</p>
          </dd>
          <dt>
            <code node-type="code">float double</code>
          </dt>
          <dd>
            <p node-type="paragraph">Scheme flonum</p>
          </dd>
          <dt>
            <code node-type="code">void*</code>
          </dt>
          <dd>
            <p node-type="paragraph">Scheme FFI pointer type</p>
          </dd>
        </dl>
        <p node-type="paragraph">NOTE: <code node-type="code">char</code> returns a Scheme integer not Scheme character.</p>
        <p node-type="paragraph"><i node-type="i">name</i> must be a symbol indicating a exported C function name.</p>
        <p node-type="paragraph"><i node-type="i">argument-types</i> must be zero or more followings;</p>
        <pre lang="scheme" node-type="block"><code>  bool
  char short int long long-long
  unsigned-short unsigned-int unsigned-long unsigned-long-long
  size_t
  void* char* wchar_t*
  float double
  int8_t  int16_t  int32_t  int64_t
  uint8_t uint16_t uint32_t uint64_t
  callback
  ___
</code></pre>
        <p node-type="paragraph">When the C function is called, given Scheme arguments will be converted to
corresponding C types. Following describes the conversion;</p>
        <dl node-type="dlist">
          <dt>
            <code node-type="code">bool</code>
          </dt>
          <dd>
            <p node-type="paragraph">Scheme boolean to C 0 (#f) or 1 (#t).</p>
          </dd>
          <dt>
            <code node-type="code">char short int long long-long unsigned-short</code>
          </dt>
          <dt>
            <code node-type="code">int8_t int16_t int32_t uint8_t uint16_t</code>
          </dt>
          <dd>
            <p node-type="paragraph">Scheme integer to C signed long int</p>
          </dd>
          <dt>
            <code node-type="code">unsigned-int unsigned-long uint32_t size_t</code>
          </dt>
          <dd>
            <p node-type="paragraph">Scheme integer to C unsigned long int</p>
          </dd>
          <dt>
            <code node-type="code">int64_t long-long</code>
          </dt>
          <dd>
            <p node-type="paragraph">Scheme integer to C int64_t</p>
          </dd>
          <dt>
            <code node-type="code">uint64_t unsigned-long-long</code>
          </dt>
          <dd>
            <p node-type="paragraph">Scheme integer to C uint64_t</p>
          </dd>
          <dt>
            <code node-type="code">float</code>
          </dt>
          <dd>
            <p node-type="paragraph">Scheme flonum to C float</p>
          </dd>
          <dt>
            <code node-type="code">double</code>
          </dt>
          <dd>
            <p node-type="paragraph">Scheme flonum to C double</p>
          </dd>
          <dt>
            <code node-type="code">void* char*</code>
          </dt>
          <dd>
            <p node-type="paragraph"><code node-type="code">void*</code> and <code node-type="code">char*</code> are actually treated the same, internally.
The conversion will be like this;</p>
          </dd>
          <dt>Scheme string</dt>
          <dd>
            <p node-type="paragraph">Converts to UTF-8 C char*</p>
          </dd>
          <dt>Scheme bytevector</dt>
          <dd>
            <p node-type="paragraph">Convert to C char*</p>
          </dd>
          <dt>Scheme FFI pointer</dt>
          <dd>
            <p node-type="paragraph">Convert to C void*</p>
          </dd>
          <dt>
            <code node-type="code">wchar_t*</code>
          </dt>
          <dd>
            <p node-type="paragraph">Wide character string conversion only happens when the given argument was
Scheme string and depends on the platform. On Windows, more specifically
size of wchar_t is 2 platform, it converts to UTF-16 string without BOM.
On other platform, size of wchar_t is 4 platform, it converts to UTF-32.
Both case detects endianness automatically.
If the given argument was bytevector, it won't convert. This case is useful
when users need to pass buffer to a C-function.</p>
          </dd>
          <dt>
            <code node-type="code">callback</code>
          </dt>
          <dd>
            <p node-type="paragraph">Scheme FFI callback to C void*</p>
          </dd>
        </dl>
        <p node-type="paragraph">Note: passing Scheme string needs to be careful when users want to use it
as a buffer. It doesn't work like it. Use bytevector or FFI pointer object
for that purpose.</p>
        <p node-type="paragraph"><code node-type="code">___</code> is for variable length argument and it must be the last position
of the argument type list, otherwise it raises an error.</p>
        <div node-type="define" class="define">
          <span>Function</span>
          <a name="make-c-function_49">
            <span>make-c-function</span>
            <span>
              <i node-type="i">shared-library</i>
            </span>
            <span>
              <i node-type="i">return-type</i>
            </span>
            <span>
              <i node-type="i">name</i>
            </span>
            <span>
              <i node-type="i">argument-types</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph">Creates C function. This procedure is underlying procedure for
<code node-type="code">c-function</code> macro. The arguments are the same as <code node-type="code">c-function</code>,
only <i node-type="i">argument-types</i> must be a list of types.</p>
        <div node-type="define" class="define">
          <span>Macro</span>
          <a name="address_19">
            <span>address</span>
            <span>
              <i node-type="i">pointer</i>
            </span>
          </a>
        </div>
        <div node-type="define" class="define">
          <span>Macro</span>
          <a name="address_18">
            <span>address</span>
            <span>
              <i node-type="i">pointer</i>
            </span>
            <span>
              <i node-type="i">offset</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph">Convenient macro for address passing.</p>
        <p node-type="paragraph">When you need to pass an address of a pointer to C function, you can write like
this;
<pre lang="" node-type="snipet"><code>(c-func (address _pointer_))</code></pre></p>
        <p node-type="paragraph">This is equivalent of following C code;
<pre lang="" node-type="snipet"><code>c_func(&amp;pointer)</code></pre></p>
        <p node-type="paragraph"><i node-type="i">pointer</i> can be a pointer object or a bytevector.</p>
        <p node-type="paragraph">If the second form is used, then the passing address is offset of <i node-type="i">offset</i>.
It is user's responsibility to make sure the given <i node-type="i">pointer</i> has enough
space when <i node-type="i">offset</i> is passed. If the <i node-type="i">pointer</i> is a bytevector and
<i node-type="i">offset</i> is more than the bytevector size, then an error is signaled.</p>
        <div node-type="define" class="define">
          <span>Macro</span>
          <a name="c-callback_0">
            <span>c-callback</span>
            <span>
              <i node-type="i">return-type</i>
            </span>
            <span>
              <i node-type="i">(argument-types</i>
            </span>
            <span>
              <i node-type="i">...</i>
            </span>
            <span>
              <i node-type="i">)</i>
            </span>
            <span>
              <i node-type="i">proc</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph">Creates a C callback.</p>
        <p node-type="paragraph"><i node-type="i">return-type</i> must be a symbol and the same as <code node-type="code">c-function</code>'s
<i node-type="i">return-type</i>.</p>
        <p node-type="paragraph"><i node-type="i">argument-types</i> must be zero or following;</p>
        <pre lang="scheme" node-type="block"><code>  bool
  char short int long long-long intptr_t
  unsigned-char unsigned-short unsigned-int unsigned-long-long uintptr_t
  int8_t int16_t int32_t int64_t
  uint8_t uint16_t uint32_t int64_t
  float double
  size_t
  void*
</code></pre>
        <p node-type="paragraph">The conversion of C to Scheme is the same as <code node-type="code">c-function</code>'s
<i node-type="i">return-type</i>.</p>
        <p node-type="paragraph">NOTE: if the content of <code node-type="code">void*</code> won't be copied, thus if you modify it in
the callback procedure, corresponding C function will get affected.</p>
        <p node-type="paragraph">NOTE: callback doesn't support <code node-type="code">char*</code> nor <code node-type="code">wchar_t*</code>. It is because
the conversion loses original pointer address and you might not want it. So
it is users responsibility to handle it.</p>
        <p node-type="paragraph"><i node-type="i">proc</i> must be a procedure takes the same number of arguments as
<i node-type="i">argument-types</i> list.</p>
        <p node-type="paragraph">Created callbacks are stored intarnal static storage to avoid to get GCed.
This is because C functions which accept callback may hold the given callback
in their storage which could be outside of Sagittarius GC root. So it is
users' responsibility to release created callback to avoid memory leak. To
release callbacks, you need to use <code node-type="code">free-c-callback</code>.</p>
        <div node-type="define" class="define">
          <span>Macro</span>
          <a name="make-c-callback_48">
            <span>make-c-callback</span>
            <span>
              <i node-type="i">return-type</i>
            </span>
            <span>
              <i node-type="i">argument-types</i>
            </span>
            <span>
              <i node-type="i">proc</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph">Creates C callback. This procedure is underlying procedure for
<code node-type="code">c-callback</code> macro. The arguments are the same as <code node-type="code">c-callback</code>,
only <i node-type="i">argument-types</i> must be a list of types.</p>
        <div node-type="define" class="define">
          <span>Function</span>
          <a name="free-c-callback_118">
            <span>free-c-callback</span>
            <span>
              <i node-type="i">callback</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph">Release <i node-type="i">callback</i>.</p>
      </section>
      <section node-type="section">
        <h3 node-type="header-3">
          <a name="Pointer-operations">Pointer operations</a>
        </h3>
        <p node-type="paragraph">Using C functions, users can not avoid to use raw pointers. This section
describes how to create or convert a pointer.</p>
        <div node-type="define" class="define">
          <span>Function</span>
          <a name="pointer?_108">
            <span>pointer?</span>
            <span>
              <i node-type="i">obj</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph">Returns #t if <i node-type="i">obj</i> is FFI pointer object, otherwise #f.</p>
        <div node-type="define" class="define">
          <span>Function</span>
          <a name="integer-&gt;pointer_68">
            <span>integer-&gt;pointer</span>
            <span>
              <i node-type="i">integer</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph">Converts given <i node-type="i">integer</i> to pointer object.</p>
        <p node-type="paragraph">To represents NULL pointer, you can write like this;
<div node-type="snipet" class="snipet">
          <pre lang="" node-type="snipet"><code>(integer-&gt;pointer 0)</code></pre>
          <span />
          <span>#\&lt;pointer 0x0&gt;</span>
        </div></p>
        <div node-type="define" class="define">
          <span>Function</span>
          <a name="pointer-&gt;integer_101">
            <span>pointer-&gt;integer</span>
            <span>
              <i node-type="i">pointer</i>
            </span>
            <span>
              <i node-type="i">:optional</i>
            </span>
            <span>
              <i node-type="i">bits</i>
            </span>
          </a>
        </div>
        <div node-type="define" class="define">
          <span>Function</span>
          <a name="pointer-&gt;uinteger_104">
            <span>pointer-&gt;uinteger</span>
            <span>
              <i node-type="i">pointer</i>
            </span>
            <span>
              <i node-type="i">:optional</i>
            </span>
            <span>
              <i node-type="i">bits</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph">Converts given <i node-type="i">pointer</i> to integer/uinteger, respectively.</p>
        <p node-type="paragraph">The optional argument <i node-type="i">bits</i> must be an exact integer range of fixnum.</p>
        <p node-type="paragraph">If the optional argument <i node-type="i">bits</i> is specified, then the procedure mask
the pointer value. If the <i node-type="i">bits</i> is negative or more than pointer size
bits then it returns non masked value.</p>
        <p node-type="paragraph">This is useful when C procedure sets the pointer value however it only sets
a half of bits and returning value is needed only a half of bits.
For example, a C procedure takes 2 arguments, one is buffer pointer the
other one is buffer size pointer. When buffer size is -1 then it allocates
sufficient buffer and sets buffer size pointer the allocated size. In this
case. In this case, if you are using 64 bit environment and buffer size
pointer is 32 bit value's pointer returning value's upper 32 bit would be
0xFFFFFFFF. If the optional argument is specified to 32 then the procedure
only returns lower 32 bit value.</p>
        <div node-type="define" class="define">
          <span>Function</span>
          <a name="pointer-&gt;string_103">
            <span>pointer-&gt;string</span>
            <span>
              <i node-type="i">pointer</i>
            </span>
            <span>
              <i node-type="i">:optional</i>
            </span>
            <span>
              <i node-type="i">(transcoder</i>
            </span>
            <span>
              <i node-type="i">(native-transcoder))</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph">Converts given <i node-type="i">pointer</i> to Scheme string.</p>
        <p node-type="paragraph">The given <i node-type="i">pointer</i> must be terminated by 0 otherwise it won't stop until
it reaches 0.</p>
        <p node-type="paragraph">If NULL pointer is given, it raises <code node-type="code">&amp;assertion</code>.</p>
        <div node-type="define" class="define">
          <span>Function</span>
          <a name="pointer-&gt;bytevector_100">
            <span>pointer-&gt;bytevector</span>
            <span>
              <i node-type="i">pointer</i>
            </span>
            <span>
              <i node-type="i">size</i>
            </span>
            <span>
              <i node-type="i">:optional</i>
            </span>
            <span>
              <i node-type="i">(offset</i>
            </span>
            <span>
              <i node-type="i">0)</i>
            </span>
            <span>
              <i node-type="i">(shared</i>
            </span>
            <span>
              <i node-type="i">#t)</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph"><i node-type="i">Size</i> must be an exact integer.</p>
        <p node-type="paragraph">Converts given <i node-type="i">pointer</i> to Scheme bytevector from given <i node-type="i">offset</i>.</p>
        <p node-type="paragraph">If optional argument <i node-type="i">shared</i> is #f, then the content of pointer won't
be shared between pointer and bytevector. Default value is #t, thus if the
given <i node-type="i">pointer</i> is modified, then the created bytevector gets affected.</p>
        <p node-type="paragraph">If NULL pointer is given, it raises <code node-type="code">&amp;assertion</code>.</p>
        <div node-type="define" class="define">
          <span>Function</span>
          <a name="bytevector-&gt;pointer_116">
            <span>bytevector-&gt;pointer</span>
            <span>
              <i node-type="i">bv</i>
            </span>
            <span>
              <i node-type="i">:optional</i>
            </span>
            <span>
              <i node-type="i">(offset</i>
            </span>
            <span>
              <i node-type="i">0)</i>
            </span>
            <span>
              <i node-type="i">(shared</i>
            </span>
            <span>
              <i node-type="i">#t)</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph">Converts given <i node-type="i">bytevector</i> to pointer from given <i node-type="i">offset</i>.</p>
        <p node-type="paragraph">If optional argument <i node-type="i">shared</i> is #f, then the content of bytevector won't
be shared between bytevector and pointer. Default value is #t, thus if the
given <i node-type="i">bv</i> is modified, then the created pointer gets affected.</p>
        <p node-type="paragraph">If NULL pointer is given, it raises <code node-type="code">&amp;assertion</code>.</p>
        <div node-type="define" class="define">
          <span>Function</span>
          <a name="object-&gt;pointer_5">
            <span>object-&gt;pointer</span>
            <span>
              <i node-type="i">obj</i>
            </span>
          </a>
        </div>
        <div node-type="define" class="define">
          <span>Function</span>
          <a name="pointer-&gt;object_102">
            <span>pointer-&gt;object</span>
            <span>
              <i node-type="i">pointer</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph">CAUTION: These operations are really dangerous especially
<code node-type="code">pointer-&gt;object</code>.</p>
        <p node-type="paragraph">Converts Scheme object to pointer and pointer to Scheme object respectively.
The operations are useful to pass Scheme object to callbacks and restore
it.</p>
        <div node-type="define" class="define">
          <span>Function</span>
          <a name="deref_128">
            <span>deref</span>
            <span>
              <i node-type="i">pointer</i>
            </span>
            <span>
              <i node-type="i">offset</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph"><i node-type="i">offset</i> must be a fixnum.</p>
        <p node-type="paragraph">Returns a pointer offset <i node-type="i">offset</i> of given <i node-type="i">pointer</i>. The same as
following C code;</p>
        <pre lang="scheme" node-type="block"><code>void* deref(void **pointer, int offset) {
  return pointer[offset]; 
}
</code></pre>
        <p node-type="paragraph">If NULL pointer is given, it raises <code node-type="code">&amp;assertion</code>.</p>
        <div node-type="define" class="define">
          <span>Function</span>
          <a name="pointer-address_105">
            <span>pointer-address</span>
            <span>
              <i node-type="i">pointer</i>
            </span>
            <span>
              <i node-type="i">:optional</i>
            </span>
            <span>
              <i node-type="i">offset</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph">Returns an address of given <i node-type="i">pointer</i>.</p>
        <p node-type="paragraph">If optional argument <i node-type="i">offset</i> is given, then the returning address of
<i node-type="i">pointer</i> is the offset of given <i node-type="i">offset</i>.</p>
        <p node-type="paragraph">NOTE: This creates a newly allocated Scheme FFI pointer object.</p>
        <p node-type="paragraph">NOTE: If the returned value is modified then given <i node-type="i">pointer</i> will be
affected.</p>
        <div node-type="define" class="define">
          <span>Function</span>
          <a name="allocate-pointer_33">
            <span>allocate-pointer</span>
            <span>
              <i node-type="i">size</i>
            </span>
            <span>
              <i node-type="i">:optional</i>
            </span>
            <span>
              <i node-type="i">(fill</i>
            </span>
            <span>
              <i node-type="i">0)</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph"><i node-type="i">size</i> must be a fixnum.</p>
        <p node-type="paragraph">Allocates a <i node-type="i">size</i> of byte memory and returns an pointer object.</p>
        <p node-type="paragraph">If optional argument <i node-type="i">fill</i> is given, it must be a fixnum, then the
procedure fill the given <i node-type="i">fill</i> into the allocated memory using
<code node-type="code">memset(3)</code>.</p>
        <p node-type="paragraph">NOTE: the <i node-type="i">fill</i> will be converted to an unsigned char by the
<code node-type="code">memset(3)</code>.</p>
        <p node-type="paragraph">The allocated memory will be GCed.</p>
        <div node-type="define" class="define">
          <span>Function</span>
          <a name="c-malloc_3">
            <span>c-malloc</span>
            <span>
              <i node-type="i">size</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph"><i node-type="i">size</i> must be a fixnum.</p>
        <p node-type="paragraph">Allocates a <i node-type="i">size</i> of byte memory and returns an pointer object using
C's <code node-type="code">malloc</code>.</p>
        <p node-type="paragraph">The allocated memory won't be GCed. So releasing the memory is users'
responsibility.</p>
        <div node-type="define" class="define">
          <span>Function</span>
          <a name="c-free_1">
            <span>c-free</span>
            <span>
              <i node-type="i">pointer</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph"><i node-type="i">pointer</i> must be a pointer created by <i node-type="i">c-malloc</i>.</p>
        <p node-type="paragraph">Release the <i node-type="i">pointer</i>.</p>
        <p node-type="paragraph">The procedure won't check if the pointer is allocated by <i node-type="i">c-malloc</i> or not.
And the behaviour when GCable pointer is passed is undefined.</p>
        <div node-type="define" class="define">
          <span>Variable</span>
          <a name="null-pointer_33">
            <span>null-pointer</span>
          </a>
        </div>
        <p node-type="paragraph">A pointer represents NULL.</p>
        <p node-type="paragraph">This value is not a constant and if you modify this by using <code node-type="code">address</code>,
you might break some codes.</p>
        <div node-type="define" class="define">
          <span>Function</span>
          <a name="null-pointer?_34">
            <span>null-pointer?</span>
            <span>
              <i node-type="i">obj</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph">Returns #t when <i node-type="i">obj</i> is a pointer representing NULL otherwise #f.</p>
        <div node-type="define" class="define">
          <span>Function</span>
          <a name="empty-pointer_2">
            <span>empty-pointer</span>
          </a>
        </div>
        <p node-type="paragraph">Creates a NULL pointer. This is for convenience.</p>
        <div node-type="define" class="define">
          <span>Function</span>
          <a name="pointer-ref-c-_106">
            <span>pointer-ref-c-</span>
            <span>
              <i node-type="i">type</i>
            </span>
            <span>
              <i node-type="i">pointer</i>
            </span>
            <span>
              <i node-type="i">offset</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph"><i node-type="i">offset</i> must be a fixnum.</p>
        <p node-type="paragraph">Returns an integer value of offset <i node-type="i">offset</i> of <i node-type="i">pointer</i> depending
on the <i node-type="i">type</i>.</p>
        <p node-type="paragraph">Following <i node-type="i">type</i> are supported;
<code node-type="code"> int8  int16  int32  int64 uint8 uint16 uint32 uint64 char wchar short  int long long-long unsigned-char unsigned-short unsigned-int unsigned-long unsigned-long-long intptr uintptr float double pointer</code>NOTE: if the <i node-type="i">type</i> is <code node-type="code">flonum</code> or <code node-type="code">double</code>, then it returns
Scheme flonum</p>
        <p node-type="paragraph">NOTE: if the <i node-type="i">type</i> is <code node-type="code">pointer</code>, then it returns Scheme FFI pointer.</p>
        <div node-type="define" class="define">
          <span>Function</span>
          <a name="pointer-set-c-_107">
            <span>pointer-set-c-</span>
            <span>
              <i node-type="i">type</i>
            </span>
            <span>
              <i node-type="i">!</i>
            </span>
            <span>
              <i node-type="i">pointer</i>
            </span>
            <span>
              <i node-type="i">offset</i>
            </span>
            <span>
              <i node-type="i">value</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph"><i node-type="i">offset</i> must be a fixnum.</p>
        <p node-type="paragraph">Sets <i node-type="i">value</i> to offset <i node-type="i">offset</i> of <i node-type="i">pointer</i>. Supporting _type_s
are the same as <code node-type="code">pointer-ref-c-_type_</code>The type conversion is the same as <code node-type="code">c-function</code>'s <i node-type="i">return-type</i>.</p>
        <p node-type="paragraph">There is no direct procedures to handle C arrays. Following is an example
of how to handle array of pointers;</p>
        <pre lang="scheme" node-type="block"><code>(import (rnrs) (sagittarius ffi))

(define (string-vector-&gt;c-array sv)
  (let ((c-array (allocate-pointer (* (vector-length sv) size-of-void*))))
    (do ((i 0 (+ i 1)))
        ((= i (vector-length sv)) c-array)
      ;; pointer-set-c-pointer! handles Scheme string (converts to UTF-8)
      ;; If you need other encoding, then you need to write other conversion
      ;; procedure.
      (pointer-set-c-pointer! c-array (* i size-of-void*) (vector-ref sv i)))))

;; how to use
(let ((p (string-vector-&gt;c-array #("abc" "def" "ghijklmn"))))
  (do ((i 0 (+ i 1)))
      ((= i 3))
    ;; deref handles pointer offset.
    ;; it can be also (pointer-ref-c-pointer p (* i size-of-void*))
    (print (pointer-&gt;string (deref p i)))))
</code></pre>
        <p node-type="paragraph">Following is an example for Scheme string to UTF-16 bytevector;</p>
        <pre lang="scheme" node-type="block"><code>(import (rnrs) (sagittarius ffi))
;; Converts to UTF16 big endian (on little endian environment)
(define (string-&gt;c-string s)
  (let* ((bv (string-&gt;utf16 s (endianness big)))
         ;; add extra 2 bytes for null terminated string
         (p  (allocate-pointer (+ (bytevector-length bv) 2))))
    (do ((i 0 (+ i 2)))
        ((= i (bytevector-length bv)) p)
      ;; pointer-set-c-uint16! uses native endianness to set the value
      ;; so this is platform dependent code.
      (pointer-set-c-uint16! p i 
        (bytevector-u16-ref bv i (endianness little))))))
</code></pre>
        <div node-type="define" class="define">
          <span>Function</span>
          <a name="set-pointer-value!_40">
            <span>set-pointer-value!</span>
            <span>
              <i node-type="i">pointer</i>
            </span>
            <span>
              <i node-type="i">value</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph"><i node-type="i">value</i> must be exact integer up to <code node-type="code">size-of-void*</code> bytes.</p>
        <p node-type="paragraph">Sets the pointer value. This is useful to reuse the existing pointer object.</p>
        <p node-type="paragraph">CAUTION: this operation is really dangerous so be aware of it!</p>
      </section>
      <section node-type="section">
        <h3 node-type="header-3">
          <a name="C-struct-operations">C struct operations</a>
        </h3>
        <p node-type="paragraph">C's struct is mere memory chunk so it is possible to access its member directly,
if you know exact offset of it. However it is convenient if you can operate
similar structure. This section describes how to define C structure in Scheme
world.</p>
        <div node-type="define" class="define">
          <span>Macro</span>
          <a name="define-c-struct_67">
            <span>define-c-struct</span>
            <span>
              <i node-type="i">name</i>
            </span>
            <span>
              <i node-type="i">clauses</i>
            </span>
            <span>
              <i node-type="i">...</i>
            </span>
          </a>
        </div>
        <div node-type="define" class="define">
          <span>Macro</span>
          <a name="define-c-struct_66">
            <span>define-c-struct</span>
            <span>
              <i node-type="i">name</i>
            </span>
            <span>
              <i node-type="i">(alignment</i>
            </span>
            <span>
              <i node-type="i">n)</i>
            </span>
            <span>
              <i node-type="i">clauses</i>
            </span>
            <span>
              <i node-type="i">...</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph">Defines C structure.</p>
        <p node-type="paragraph"><i node-type="i">clauses</i> must be following form;</p>
        <pre lang="scheme" node-type="block"><code>(_type_ _name_)
(_type_ `array` _size_ _name_)
(`struct` _struct-name_ _name_)
(`bit-field` _type_ (_name_ _bit_) ...)
(`bit-field` (_type_ _endian_) (_name_ _bit_) ...)
</code></pre>
        <p node-type="paragraph"><i node-type="i">name</i> must be a symbol.</p>
        <p node-type="paragraph">If the second form is used, then <code node-type="code">alignment</code> is an auxiliary syntax
and <i node-type="i">n</i> must be an integer which must be either negative number or
one of <code node-type="code">1</code>, <code node-type="code">2</code>, <code node-type="code">4</code>, <code node-type="code">8</code>, or <code node-type="code">16</code>. This form
specifies the alignemtn of the struct. If the <i node-type="i">n</i> is negative number,
then it uses platform default alignment, if it's one of the above number,
then the alignment is according to the given number.</p>
        <p node-type="paragraph">The first form is the simple C type form. <i node-type="i">type</i> must be a symbol and the
same as one of the <code node-type="code">c-function</code>'s <i node-type="i">return-types</i> or <code node-type="code">callback</code>.
Following describes the concrete example and the equivalent C structure:</p>
        <pre lang="scheme" node-type="block"><code>(define-c-struct st
  (int foo)
  (callback fn))
#|
struct st
{
  int foo;
  void* fn; /* function pointer */
};
|#
</code></pre>
        <p node-type="paragraph">The second form is defining C <i node-type="i">type</i> array with <i node-type="i">size</i>.
Following describes the concrete example and the equivalent C structure:</p>
        <pre lang="scheme" node-type="block"><code>(define-c-struct st
  (int array 10 foo))
#|
struct st
{
  int foo[10];
};
|#
</code></pre>
        <p node-type="paragraph">The third form is defining internal structure.
Following describes the concrete example and the equivalent C structure:</p>
        <pre lang="scheme" node-type="block"><code>(define-c-struct st1
  (int array 10 foo))
(define-c-struct st2
  (struct st1 st)
  (int bar))
#|
struct st1
{
  int foo[10];
};
struct st2
{
  struct st1 st;
  int bar;
};
|#
</code></pre>
        <p node-type="paragraph">So far, we don't support direct internal structure so users always need to
extract internal structures.</p>
        <p node-type="paragraph">The forth and fifth forms are bit fields. <i node-type="i">type</i> must be an integer
type such as <code node-type="code">unsigned-int</code>. If the given <i node-type="i">type</i> is not an integer,
then <code node-type="code">&amp;assertion</code> is raised.</p>
        <p node-type="paragraph">Following describes the concrete example and the equivalent C structure:</p>
        <pre lang="scheme" node-type="block"><code>(define-c-struct st1
  (bit-field unsigned-int (a 10) (b 20)))
#|
struct st1
{
  unsigned int a : 10;
  unsigned int b : 20;
};
|#
</code></pre>
        <p node-type="paragraph">If the fifth form is used, then <i node-type="i">endian</i> must be an identifier which has
valid name for <code node-type="code">endianness</code> macro. Then the created structure packs
the value according to the given <i node-type="i">endian</i>.</p>
        <p node-type="paragraph">If the total amount of bits is greater than given <i node-type="i">type</i>, then
<code node-type="code">&amp;assertion</code> is raised.</p>
        <p node-type="paragraph">NOTE: Even though, this can accept signed integer the returning value would
not be signed. It is safe to specify unsigned type.</p>
        <p node-type="paragraph">The macro also defines accessors for the c-struct. Following naming rules are
applied;</p>
        <ul node-type="bullet-list">
          <li>
            <p node-type="paragraph">For getter: <i node-type="i">name</i>-<i node-type="i">member-name</i>-ref</p>
          </li>
          <li>
            <p node-type="paragraph">For setter: <i node-type="i">name</i>-<i node-type="i">member-name</i>-set!</p>
          </li>
        </ul>
        <p node-type="paragraph">The macro also defines size variable for the c-struct. If the name of the
c-struct if <i node-type="i">foo</i>, then the variable name will be <code node-type="code">size-of-foo</code>.</p>
        <div node-type="define" class="define">
          <span>Function</span>
          <a name="size-of-c-struct_116">
            <span>size-of-c-struct</span>
            <span>
              <i node-type="i">struct</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph"><i node-type="i">struct</i> must be a C structure defined by <code node-type="code">define-c-struct</code>.</p>
        <p node-type="paragraph">Returns the size of given <i node-type="i">struct</i>.</p>
        <div node-type="define" class="define">
          <span>Function</span>
          <a name="allocate-c-struct_32">
            <span>allocate-c-struct</span>
            <span>
              <i node-type="i">struct</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph">Allocates memory for <i node-type="i">struct</i> and returns a pointer.</p>
        <div node-type="define" class="define">
          <span>Function</span>
          <a name="_struct-name__1">
            <span>_struct-name_</span>
            <span>
              <i node-type="i">-</i>
            </span>
            <span>
              <i node-type="i">member-name</i>
            </span>
            <span>
              <i node-type="i">-ref</i>
            </span>
            <span>
              <i node-type="i">struct-pointer</i>
            </span>
            <span>
              <i node-type="i">inner-member-names</i>
            </span>
            <span>
              <i node-type="i">...</i>
            </span>
          </a>
        </div>
        <div node-type="define" class="define">
          <span>Function</span>
          <a name="_struct-name__0">
            <span>_struct-name_</span>
            <span>
              <i node-type="i">-</i>
            </span>
            <span>
              <i node-type="i">member-name</i>
            </span>
            <span>
              <i node-type="i">-set!</i>
            </span>
            <span>
              <i node-type="i">struct-pointer</i>
            </span>
            <span>
              <i node-type="i">value</i>
            </span>
            <span>
              <i node-type="i">inner-member-names</i>
            </span>
            <span>
              <i node-type="i">...</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph">A getter/setter of <i node-type="i">struct-name</i> c-struct.</p>
        <p node-type="paragraph">This is automatically defined by <code node-type="code">define-c-struct</code> macro.</p>
        <p node-type="paragraph">The optional argument <i node-type="i">inner-member-names</i> can be passed to get inner
struct values.</p>
        <p node-type="paragraph">Following describes how it works.</p>
        <pre lang="scheme" node-type="block"><code>(define-c-struct in
  (int  i)
  (char c))
(define-c-struct out
  (int  i)
  (struct in in0))

(define out (allocate-c-struct out))
(out-i-set! out 100 'i)   ;; -&gt; unspecified
(out-in0-set! out 200 'i) ;; -&gt; unspecified
(out-i-ref out)           ;; -&gt; 100
(out-in0-ref out 'i)      ;; -&gt; 200
(out-in0-ref out)         ;; -&gt; pointer object (indicating the inner struct address)
</code></pre>
        <section node-type="section">
          <h4 node-type="header-4">
            <a name="Low-level-C-struct-accessors">Low level C struct accessors</a>
          </h4>
          <div node-type="define" class="define">
            <span>Function</span>
            <a name="c-struct-ref_4">
              <span>c-struct-ref</span>
              <span>
                <i node-type="i">pointer</i>
              </span>
              <span>
                <i node-type="i">struct</i>
              </span>
              <span>
                <i node-type="i">name</i>
              </span>
            </a>
          </div>
          <p node-type="paragraph"><i node-type="i">struct</i> must be a C structure defined with <code node-type="code">define-c-struct</code>.
<i node-type="i">name</i> must be a symbol and <i node-type="i">struct</i> has the same member.
<i node-type="i">pointer</i> should be a pointer allocated by <code node-type="code">allocate-c-struct</code> with
<i node-type="i">struct</i>.</p>
          <p node-type="paragraph">Returns a member <i node-type="i">name</i>'s value of <i node-type="i">struct</i> from <i node-type="i">pointer</i>.</p>
          <div node-type="define" class="define">
            <span>Function</span>
            <a name="c-struct-set!_5">
              <span>c-struct-set!</span>
              <span>
                <i node-type="i">pointer</i>
              </span>
              <span>
                <i node-type="i">struct</i>
              </span>
              <span>
                <i node-type="i">name</i>
              </span>
              <span>
                <i node-type="i">value</i>
              </span>
            </a>
          </div>
          <p node-type="paragraph"><i node-type="i">struct</i> must be a C structure defined with <code node-type="code">define-c-struct</code>.
<i node-type="i">name</i> must be a symbol and <i node-type="i">struct</i> has the same member.
<i node-type="i">pointer</i> should be a pointer allocated by <code node-type="code">allocate-c-struct</code> with
<i node-type="i">struct</i>.</p>
          <p node-type="paragraph">Sets <i node-type="i">value</i> to <i node-type="i">pointer</i> offset of member <i node-type="i">name</i> of <i node-type="i">struct</i>.</p>
        </section>
      </section>
      <section node-type="section">
        <h3 node-type="header-3">
          <a name="Typedef-operations">Typedef operations</a>
        </h3>
        <div node-type="define" class="define">
          <span>Macro</span>
          <a name="define-c-typedef_68">
            <span>define-c-typedef</span>
            <span>
              <i node-type="i">original</i>
            </span>
            <span>
              <i node-type="i">new-names</i>
            </span>
            <span>
              <i node-type="i">...</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph">Convenient macro.</p>
        <p node-type="paragraph">Defines other name of <i node-type="i">original</i> with <i node-type="i">new-names</i>.</p>
        <p node-type="paragraph"><i node-type="i">new-names</i> must be following forms;</p>
        <pre lang="scheme" node-type="block"><code>()
((`*` _new-p_) _rest_ ...)
((`s*` _new-sp_) _rest_ ...)
(_new_ _rest_ ...)
</code></pre>
        <p node-type="paragraph">The first for defines nothing.</p>
        <p node-type="paragraph">If the rest of form is used and <i node-type="i">rest</i> is not null, then it will recursively
define.</p>
        <p node-type="paragraph">The second form's <code node-type="code">*</code> defines <i node-type="i">new-p</i> as <code node-type="code">void*</code>.</p>
        <p node-type="paragraph">The third form's <code node-type="code">s*</code> defines <i node-type="i">new-sp</i> as <code node-type="code">char*</code>.</p>
        <p node-type="paragraph">The forth form defines <i node-type="i">new</i> as <i node-type="i">original</i>.</p>
        <p node-type="paragraph">Following example describes how to will be expanded approximately.</p>
        <pre lang="scheme" node-type="block"><code>(define-c-typedef char (* char_ptr) byte (s* string))

=&gt; 

(begin
  (define char_ptr void*)
  (define byte char)
  (define string char*)
)
</code></pre>
      </section>
      <section node-type="section">
        <h3 node-type="header-3">
          <a name="Sizes-and-aligns">Sizes and aligns</a>
        </h3>
        <div node-type="define" class="define">
          <span>Constant</span>
          <a name="size-of-_115">
            <span>size-of-</span>
            <span>
              <i node-type="i">type</i>
            </span>
          </a>
        </div>
        <div node-type="define" class="define">
          <span>Constant</span>
          <a name="align-of-_27">
            <span>align-of-</span>
            <span>
              <i node-type="i">type</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph">a size or align of <i node-type="i">type</i>, respectively.</p>
        <p node-type="paragraph">Following types are supported;</p>
        <pre lang="scheme" node-type="block"><code>  bool char
  short int long long-long
  unsigned-short unsigned-int unsigned-long unsigned-long-long
  intptr_t uintptr_t size_t
  float double
  int8_t  int16_t  int32_t  int64_t
  uint8_t uint16_t uint32_t uint64_t
  void*
</code></pre>
        <p node-type="paragraph">The values are platform dependent.</p>
      </section>
      <section node-type="section">
        <h3 node-type="header-3">
          <a name="Finalizer-operations">Finalizer operations</a>
        </h3>
        <p node-type="paragraph">Some of C resource must be released but if you can not decide or do not want to
restrict when, then you can release it at GC time.</p>
        <p node-type="paragraph">NOTE: GC might not happen if your script is very short, so it is better not to
relay these procedures too much.</p>
        <div node-type="define" class="define">
          <span>Function</span>
          <a name="register-ffi-finalizer_100">
            <span>register-ffi-finalizer</span>
            <span>
              <i node-type="i">pointer</i>
            </span>
            <span>
              <i node-type="i">proc</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph"><i node-type="i">pointer</i> must be a pointer allocated with GCable memory.</p>
        <p node-type="paragraph"><i node-type="i">proc</i> must be a procedure and accepts one argument. The argument will be
the <i node-type="i">pointer</i>.</p>
        <p node-type="paragraph">Register <i node-type="i">proc</i> as <i node-type="i">pointer</i>'s finalizer and returns <i node-type="i">pointer</i>.</p>
        <div node-type="define" class="define">
          <span>Function</span>
          <a name="unregister-ffi-finalizer_15">
            <span>unregister-ffi-finalizer</span>
            <span>
              <i node-type="i">pointer</i>
            </span>
          </a>
        </div>
        <p node-type="paragraph"><i node-type="i">pointer</i> must be a pointer allocated with GCable memory.</p>
        <p node-type="paragraph">Remove finalizer form <i node-type="i">pointer</i> and returns <i node-type="i">pointer</i>.</p>
      </section>
    </section>
    <p node-type="paragraph" class="navigation-container">
      <a href="./section62.html">(sagittarius control) - control library</a>
      <a href="../sagittarius-online-ref.html">Top</a>
      <a href="./section64.html">(sagittarius filewatch) - Monitoring filesystem</a>
    </p>
    <div node-type="section">
      <hr>
      <p node-type="paragraph" class="author footer">This document was generated by <i node-type="i">Takashi Kato</i> with Sagittarius gendoc.<br>Generated date: <i node-type="i">2024-09-09T21:26:28+0200</i></p>
    </div>
  </body>
</html>