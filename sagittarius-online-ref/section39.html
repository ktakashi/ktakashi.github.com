<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-eqiv="Content-Type" content="text/html; charset=utf-8">
    <link rel="stylesheet" type="text/css" href="../lib/style.css">
    <title>Sagittarius Users' Reference</title>
  </head>
  <div class="prev-next">
    <a class="prev" href="section38.html">Control structures</a>
    <a class="top" href="../sagittarius-online-ref.html">Top</a>
    <a class="next" href="section310.html">Records procedural layer</a>
  </div>
  <section class="subsection"><h3 class="subsection">
    <a class="section.anchor" name="rnrs.records.syntactic.6"><span class="section-number">3.9</span>Records syntactic layer</a>
  </h3>
<p /><div class="define">
    <span class="define-category">Library</span>
    <a name="(rnrs records syntactic (6))364">
      <span class="name" name="(rnrs records syntactic (6))">(rnrs records syntactic (6))</span>
    </a>
  </div>
<div class="desc">The <code>(rnrs records syntactic (6))</code>library. Some details of the
specification are explained in terms of the specification of the procedural
layer below.
</div>
<p /><div class="define"><span class="define-category">Macro</span><a name="define-record-type365">
    <span class="name" name="define-record-type">define-record-type</span>
  </a> <span class="args">name-spec record-clase ...</span></div>
<div class="define"><span class="define-category">Auxiliary syntax</span><a name="fields366">
    <span class="name" name="fields">fields</span>
  </a> <span class="args">field-spec ...</span></div>
<div class="define"><span class="define-category">Auxiliary syntax</span><a name="parent367">
    <span class="name" name="parent">parent</span>
  </a> <span class="args">parent-name</span></div>
<div class="define"><span class="define-category">Auxiliary syntax</span><a name="protocol368">
    <span class="name" name="protocol">protocol</span>
  </a> <span class="args">expression</span></div>
<div class="define"><span class="define-category">Auxiliary syntax</span><a name="sealed369">
    <span class="name" name="sealed">sealed</span>
  </a> <span class="args">boolean</span></div>
<div class="define"><span class="define-category">Auxiliary syntax</span><a name="opaque370">
    <span class="name" name="opaque">opaque</span>
  </a> <span class="args">boolean</span></div>
<div class="define"><span class="define-category">Auxiliary syntax</span><a name="nongenerative371">
    <span class="name" name="nongenerative">nongenerative</span>
  </a> <span class="args">:optional uid</span></div>
<div class="define"><span class="define-category">Auxiliary syntax</span><a name="parent-rtd372">
    <span class="name" name="parent-rtd">parent-rtd</span>
  </a> <span class="args">parent-rtd parent-cd</span></div>
<div class="desc">[R6RS] A <code>define-record-type</code> form defines a record type along with
associated constructor descriptor and constructor, predicate, field accessors,
and field mutators. The <code>define-record-type</code> form expands into a set of
definitions in the environment where <code>define-record-type</code> appears; hence,
it is possible to refer to the bindings (except for that of the record type
itself) recursively.
<p />The <var>name-spec</var> specifies the names of the record type, constructor, and
predicate. It must take one of the following forms:
<p /><pre class="snipet">(<var>record-name</var> <var>constructor-name</var> <var>predicate-name</var>)</pre>
<pre class="snipet"><var>record-name</var></pre>
<p /><var>Record-name</var>, <var>constructor-name</var>, and <var>predicate-name</var> must all be
identifiers.
<var>Record-name</var>, taken as a symbol, becomes the name of the record type.
(See the description of <see>make-record-type-descriptor</see>.) Additionally, it is
bound by this definition to an expand-time or run-time representation of the
record type and can be used as parent name in syntactic record-type definitions
that extend this definition. It can also be used as a handle to gain access to
the underlying record-type descriptor and constructor descriptor
(see <see>record-type-descriptor</see> and <see>record-constructor-descriptor</see>).
<p /><var>Constructor-name</var> is defined by this definition to be a constructor for the
defined record type, with a protocol specified by the <code>protocol</code> clause, or,
in its absence, using a default protocol. For details, see the description of the
<code>protocol</code> clause below.
<p /><var>Predicate-name</var> is defined by this definition to a predicate for the defined
record type.
<p />The second form of <var>name-spec</var> is an abbreviation for the first form, where
the name of the constructor is generated by prefixing the record name with 
<code>make-</code>, and the predicate name is generated by adding a question mark 
(<code>?</code>) to the end of the record name. For example, if the record name is 
<code>frob</code>, the name of the constructor is <code>make-frob</code>, and the predicate
name is <code>frob?</code>
.
Each <var>record-clause</var> must take one of the auxiliary syntax forms; it is a
syntax violation if multiple <var>record-clauses</var> of the same kind appear in a
<code>define-record-type</code> form.
<p /><pre class="snipet">(fields <var>field-spec</var>*)</pre>
<p />Each <var>field-spec</var> has one of the following forms
<p /><pre class="snipet">(immutable <var>field-name</var> <var>accessor-name</var>)</pre>
<pre class="snipet">(mutable <var>field-name</var> <var>accessor-name</var> <var>mutator-name</var>)</pre>
<pre class="snipet">(immutable <var>field-name</var>)</pre>
<pre class="snipet">(mutable <var>field-name</var>)</pre>
<pre class="snipet"><var>field-name</var></pre>
<p /><var>Field-name</var>, <var>accessor-name</var>, and <var>mutator-name</var> must all be identifiers.
The first form declares an immutable field called field-name&gt;, with the corresponding
accessor named <var>accessor-name</var>. The second form declares a mutable field called
<var>field-name</var>, with the corresponding accessor named <var>accessor-name</var>, and
with the corresponding mutator named <var>mutator-name</var>.
<p />If <var>field-spec</var> takes the third or fourth form, the accessor name is generated
by appending the record name and field name with a hyphen separator, and the mutator
name (for a mutable field) is generated by adding a <code>-set!</code> suffix to the
accessor name. For example, if the record name is <code>frob</code> and the field name
is <code>widget</code>, the accessor name is <code>frob-widget</code> and the mutator name is
<code>frob-widget-set!</code>.
<p />If <var>field-spec</var> is just a <var>field-name</var> form, it is an abbreviation for
<code>(immutable <var>field-name</var>)</code>.
<p />The <var>field-names</var> become, as symbols, the names of the fields in the
<code>record-type</code> descriptor being created, in the same order.
<p />The <code>fields</code> clause may be absent; this is equivalent to an empty <code>fields</code>
clause.
<p /><pre class="snipet">(parent <var>parent-name</var>)</pre>
<p />Specifies that the record type is to have parent type <var>parent-name</var>, where
<var>parent-name</var> is the <var>record-name</var> of a record type previously defined
using <code>define-record-type</code>. The record-type definition associated with
<var>parent-name</var> must not be sealed. If no parent clause and no <code>parent-rtd</code>
(see below) clause is present, the record type is a base type.
<p /><pre class="snipet">(protocol <var>expression</var>)</pre>
<p /><var>Expression</var> is evaluated in the same environment as the <code>define-record-type</code>
form, and must evaluate to a protocol appropriate for the record type being defined.
<p />The protocol is used to create a record-constructor descriptor as described below.
If no <code>protocol</code> clause is specified, a constructor descriptor is still created
using a default protocol. The clause can be absent only if the record type being
defined has no parent type, or if the parent definition does not specify a protocol.
<p /><pre class="snipet">(sealed <var>boolean</var>)</pre>
<p />If this option is specified with operand #t, the defined record type is sealed,
i.e., no extensions of the record type can be created. If this option is specified
with operand #f, or is absent, the defined record type is not sealed.
<p /><pre class="snipet">(opaque <var>boolean</var>)</pre>
<p />If this option is specified with operand #t, or if an opaque parent record type is
specified, the defined record type is opaque. Otherwise, the defined record type is
not opaque. See the specification of record-rtd below for details.
<p /><pre class="snipet">(nongenerative <var>uid</var>)</pre>
<pre class="snipet">(nongenerative)</pre>
<p />This specifies that the record type is nongenerative with uid <var>uid</var>, which must
be an identifier. If <var>uid</var> is absent, a unique uid is generated at macro-expansion
time. If two record-type definitions specify the same uid, then the record-type
definitions should be equivalent, i.e., the implied arguments to 
<code>make-record-type-descriptor</code> must be equivalent as described under
<code>make-record-type-descriptor</code>. If this condition is not met, it is either
considered a syntax violation or an exception with condition type <code>&amp;assertion</code>
is raised. If the condition is met, a single record type is generated for both
definitions.
<p />In the absence of a <code>nongenerative</code> clause, a new record type is generated
every time a <code>define-record-type</code> form is evaluated:
<p /><div class="codeblock-box">
    <pre class="codeblock">(let ((f (lambda (x)
           (define-record-type r ...)
           (if x r? (make-r ...)))))
  ((f #t) (f #f)))
</pre>
    <span class="codeblock-arrow">=&gt;</span>
    <span class="codeblock-result">#f</span>
  </div>
<p /><pre class="snipet">(parent-rtd <var>parent-rtd</var> <var>parent-cd</var>)</pre>
<p />Specifies that the record type is to have its parent type specified by
<var>parent-rtd</var>, which should be an expression evaluating to a record-type
descriptor, and <var>parent-cd</var>, which should be an expression evaluating to a
constructor descriptor. The record-type definition associated with the value of
<var>parent-rtd</var> must not be sealed. Moreover, a record-type definition must not
have both a <code>parent</code> and a <code>parent-rtd</code> clause.
<p />All bindings created by <code>define-record-typ</code>e (for the record type, the
constructor, the predicate, the accessors, and the mutators) must have names that
are pairwise distinct.
<p />The constructor created by a <code>define-record-type</code> form is a procedure as
follows:
<p /><ul class="itemlist">
    <li class="itemlist-item">If there is no <code>parent</code> clause and no <code>protocol</code> clause, the
constructor accepts as many arguments as there are fields, in the same order
as they appear in the <code>fields</code> clause, and returns a record object with
the fields initialized to the corresponding arguments.</li>
    <li class="itemlist-item">If there is no <code>parent</code> or <code>parent-rtd</code> clause and a <code>protocol</code>
clause, the protocol expression must evaluate to a procedure that accepts a
single argument. The protocol procedure is called once during the evaluation of
the <code>define-record-type</code> form with a procedure <var>p</var> as its argument. It
should return a procedure, which will become the constructor bound to
<var>constructor-name</var>. The procedure <var>p</var> accepts as many arguments as there
are fields, in the same order as they appear in the fields clause, and returns
a record object with the fields initialized to the corresponding arguments.
<p />The constructor returned by the protocol procedure can accept an arbitrary number
of arguments, and should call <var>p</var> once to construct a record object, and
return that record object.
<p />For example, the following protocol expression for a record-type definition with
three fields creates a constructor that accepts values for all fields, and
initialized them in the reverse order of the arguments:
<pre class="codeblock">(lambda (p)
  (lambda (v1 v2 v3)
    (p v3 v2 v1)))
</pre>
</li>
    <li class="itemlist-item">If there is both a <code>parent</code> clause and a <code>protocol</code> clause, then
the protocol procedure is called once with a procedure <var>n</var>as its argument.
As in the previous case, the protocol procedure should return a procedure, which
will become the constructor bound to <var>constructor-name</var>. However, <var>n</var> is
different from <var>p</var> in the previous case: It accepts arguments corresponding
to the arguments of the constructor of the parent type. It then returns a procedure
<var>p</var> that accepts as many arguments as there are (additional) fields in this
type, in the same order as in the <code>fields</code> clause, and returns a record object
with the fields of the parent record types initialized according to their constructors
and the arguments to <var>n</var>, and the fields of this record type initialized to
its arguments of <var>p</var>.
<p />The constructor returned by the protocol procedure can accept an arbitrary number
of arguments, and should call <var>n</var> once to construct the procedure <var>p</var>,
and call <var>p</var> once to create the record object, and finally return that record
object.
<p />For example, the following protocol expression assumes that the constructor of
the parent type takes three arguments:
<p /><pre class="codeblock">(lambda (n)
  (lambda (v1 v2 v3 x1 x2 x3 x4)
    (let ((p (n v1 v2 v3)))
      (p x1 x2 x3 x4))))
</pre>
<p />The resulting constructor accepts seven arguments, and initializes the fields of
the parent types according to the constructor of the parent type, with <code>v1</code>,
<code>v2</code>, and <code>v3</code> as arguments. It also initializes the fields of this
record type to the values of <code>x1</code>, ..., <code>x4</code>.
</li>
    <li class="itemlist-item">If there is a <code>parent</code> clause, but no <code>protocol</code> clause, then the
parent type must not have a <code>protocol</code> clause itself. The constructor bound
to <var>constructor-name</var> is a procedure that accepts arguments corresponding to
the parent types' constructor first, and then one argument for each field in the
same order as in the <code>fields</code> clause. The constructor returns a record object
with the fields initialized to the corresponding arguments.
</li>
    <li class="itemlist-item">If there is a <code>parent-rtd</code> clause, then the constructor is as with a
<code>parent</code> clause, except that the constructor of the parent type is determined
by the constructor descriptor of the <code>parent-rtd</code> clause.
</li>
  </ul>
<p />A protocol may perform other actions consistent with the requirements described
above, including mutation of the new record or other side effects, before returning
the record.
<p />Any definition that takes advantage of implicit naming for the constructor,
predicate, accessor, and mutator names can be rewritten trivially to a definition
that specifies all names explicitly. For example, the implicit-naming record
definition:
<p /><pre class="codeblock">(define-record-type frob
  (fields (mutable widget))
  (protocol
    (lambda (p)
      (lambda (n) (p (make-widget n))))))
</pre>
<p />is equivalent to the following explicit-naming record definition.
<p /><pre class="codeblock">(define-record-type (frob make-frob frob?)
  (fields (mutable widget
                   frob-widget
                   frob-widget-set!))
  (protocol
    (lambda (p)
      (lambda (n) (p (make-widget n))))))
</pre>
<p />Also, the implicit-naming record definition:
<p /><pre class="snipet">(define-record-type point (fields x y))</pre>
<p />is equivalent to the following explicit-naming record definition:
<p /><pre class="codeblock">(define-record-type (point make-point point?)
  (fields 
    (immutable x point-x)
    (immutable y point-y)))
</pre>
<p />With implicit naming, it is still possible to specify some of the names explicitly;
for example, the following overrides the choice of accessor and mutator names for
the widget field.
<p /><pre class="codeblock">(define-record-type frob
  (fields (mutable widget getwid setwid!))
  (protocol
    (lambda (p)
      (lambda (n) (p (make-widget n))))))
</pre>
</div>
<p /><div class="define"><span class="define-category">Macro</span><a name="record-type-descriptor373">
    <span class="name" name="record-type-descriptor">record-type-descriptor</span>
  </a> <span class="args">record-name</span></div>
<div class="desc">[R6RS] Evaluates to the record-type descriptor (see 
<a href="section310.html#rnrs.records.procedural.6">Records procedural layer</a>) associated with the type specified by
<var>record-name</var>.
</div>
<p /><div class="define"><span class="define-category">Macro</span><a name="record-constructor-descriptor374">
    <span class="name" name="record-constructor-descriptor">record-constructor-descriptor</span>
  </a> <span class="args">record-name</span></div>
<div class="desc">[R6RS] Evaluates to the record-type constructor (see
<a href="section310.html#rnrs.records.procedural.6">Records procedural layer</a>) associated with the type specified by
<var>record-name</var>.
<p />The following example uses the <code>record?</code> procedure from the
<code>(rnrs records inspection (6))</code> library:
<p /><pre class="codeblock">(define-record-type (point make-point point?)
  (fields (immutable x point-x)
           (mutable y point-y set-point-y!))
  (nongenerative point-4893d957-e00b-11d9-817f-00111175eb9e))
</pre>
<pre class="codeblock">(define-record-type (cpoint make-cpoint cpoint?)
  (parent point)
  (protocol (lambda (n)
                 (lambda (x y c) 
                   ((n x y) (color-&gt;rgb c)))))
  (fields (mutable rgb cpoint-rgb cpoint-rgb-set!)))
</pre>
<pre class="snipet">(define (color-&gt;rgb c) (cons 'rgb c))</pre>
<pre class="snipet">(define p1 (make-point 1 2))</pre>
<pre class="snipet">(define p2 (make-cpoint 3 4 'red))</pre>
<p /><div class="snipet-box">
    <pre class="snipet">(point? p1)</pre>
    <span class="snipet-arrow">=&gt;</span>
    <span class="snipet-result">#t</span>
  </div>
<div class="snipet-box">
    <pre class="snipet">(point? p2)</pre>
    <span class="snipet-arrow">=&gt;</span>
    <span class="snipet-result">#t</span>
  </div>
<div class="snipet-box">
    <pre class="snipet">(point? (vector))</pre>
    <span class="snipet-arrow">=&gt;</span>
    <span class="snipet-result">#f</span>
  </div>
<div class="snipet-box">
    <pre class="snipet">(point? (cons 'a 'b))</pre>
    <span class="snipet-arrow">=&gt;</span>
    <span class="snipet-result">#f</span>
  </div>
<div class="snipet-box">
    <pre class="snipet">(cpoint? p1)</pre>
    <span class="snipet-arrow">=&gt;</span>
    <span class="snipet-result">#f</span>
  </div>
<div class="snipet-box">
    <pre class="snipet">(cpoint? p2)</pre>
    <span class="snipet-arrow">=&gt;</span>
    <span class="snipet-result">#t</span>
  </div>
<div class="snipet-box">
    <pre class="snipet">(point-x p1)</pre>
    <span class="snipet-arrow">=&gt;</span>
    <span class="snipet-result">1</span>
  </div>
<div class="snipet-box">
    <pre class="snipet">(point-y p1)</pre>
    <span class="snipet-arrow">=&gt;</span>
    <span class="snipet-result">2</span>
  </div>
<div class="snipet-box">
    <pre class="snipet">(point-x p2)</pre>
    <span class="snipet-arrow">=&gt;</span>
    <span class="snipet-result">3</span>
  </div>
<div class="snipet-box">
    <pre class="snipet">(point-y p2)</pre>
    <span class="snipet-arrow">=&gt;</span>
    <span class="snipet-result">4</span>
  </div>
<div class="snipet-box">
    <pre class="snipet">(cpoint-rgb p2)</pre>
    <span class="snipet-arrow">=&gt;</span>
    <span class="snipet-result">(rgb . red)</span>
  </div>
<p /><div class="snipet-box">
    <pre class="snipet">(set-point-y! p1 17)</pre>
    <span class="snipet-arrow">=&gt;</span>
    <span class="snipet-result">unspecified</span>
  </div>
<div class="snipet-box">
    <pre class="snipet">(point-y p1)</pre>
    <span class="snipet-arrow">=&gt;</span>
    <span class="snipet-result">17</span>
  </div>
<p /><div class="snipet-box">
    <pre class="snipet">(record-rtd p1)</pre>
    <span class="snipet-arrow">=&gt;</span>
    <span class="snipet-result">(record-type-descriptor point)</span>
  </div>
<p /><pre class="codeblock">(define-record-type (ex1 make-ex1 ex1?)
  (protocol (lambda (p) (lambda a (p a))))
  (fields (immutable f ex1-f)))
</pre>
<p /><pre class="snipet">(define ex1-i1 (make-ex1 1 2 3))</pre>
<div class="snipet-box">
    <pre class="snipet">(ex1-f ex1-i1)</pre>
    <span class="snipet-arrow">=&gt;</span>
    <span class="snipet-result">(1 2 3)</span>
  </div>
<p /><pre class="codeblock">(define-record-type (ex2 make-ex2 ex2?)
  (protocol
    (lambda (p) (lambda (a . b) (p a b))))
  (fields (immutable a ex2-a)
           (immutable b ex2-b)))
</pre>
<p /><pre class="snipet">(define ex2-i1 (make-ex2 1 2 3))</pre>
<div class="snipet-box">
    <pre class="snipet">(ex2-a ex2-i1)</pre>
    <span class="snipet-arrow">=&gt;</span>
    <span class="snipet-result">1</span>
  </div>
<div class="snipet-box">
    <pre class="snipet">(ex2-b ex2-i1)</pre>
    <span class="snipet-arrow">=&gt;</span>
    <span class="snipet-result">(2 3)</span>
  </div>
<p /><pre class="codeblock">(define-record-type (unit-vector make-unit-vector unit-vector?)
  (protocol (lambda (p)
                 (lambda (x y z)
                   (let ((length (sqrt (+ (* x x) (* y y) (* z z)))))
                         (p (/ x length) (/ y length) (/ z length))))))
  (fields (immutable x unit-vector-x)
           (immutable y unit-vector-y)
           (immutable z unit-vector-z)))
</pre>
<p /><pre class="snipet">(define *ex3-instance* #f)</pre>
<p /><pre class="codeblock">(define-record-type ex3
  (parent cpoint)
  (protocol (lambda (n)
                 (lambda (x y t)
                   (let ((r ((n x y 'red) t)))
                     (set! *ex3-instance* r)
                     r))))
  (fields  (mutable thickness))
  (sealed #t) (opaque #t))
</pre>
<p /><pre class="snipet">(define ex3-i1 (make-ex3 1 2 17))</pre>
<div class="snipet-box">
    <pre class="snipet">(ex3? ex3-i1)</pre>
    <span class="snipet-arrow">=&gt;</span>
    <span class="snipet-result">#t</span>
  </div>
<div class="snipet-box">
    <pre class="snipet">(cpoint-rgb ex3-i1)</pre>
    <span class="snipet-arrow">=&gt;</span>
    <span class="snipet-result">(rgb . red)</span>
  </div>
<div class="snipet-box">
    <pre class="snipet">(ex3-thickness ex3-i1)</pre>
    <span class="snipet-arrow">=&gt;</span>
    <span class="snipet-result">17</span>
  </div>
<div class="snipet-box">
    <pre class="snipet">(ex3-thickness-set! ex3-i1 18)</pre>
    <span class="snipet-arrow">=&gt;</span>
    <span class="snipet-result">unspecified</span>
  </div>
<div class="snipet-box">
    <pre class="snipet">(ex3-thickness ex3-i1)</pre>
    <span class="snipet-arrow">=&gt;</span>
    <span class="snipet-result">18</span>
  </div>
<div class="snipet-box">
    <pre class="snipet">*ex3-instance*</pre>
    <span class="snipet-arrow">=&gt;</span>
    <span class="snipet-result">ex3-i1</span>
  </div>
<div class="snipet-box">
    <pre class="snipet">(record? ex3-i1)</pre>
    <span class="snipet-arrow">=&gt;</span>
    <span class="snipet-result">#f</span>
  </div>
</div>

</section>
  <div class="prev-next">
    <a class="prev" href="section38.html">Control structures</a>
    <a class="top" href="../sagittarius-online-ref.html">Top</a>
    <a class="next" href="section310.html">Records procedural layer</a>
  </div>
  <hr>
  <div id="document-footer">
    <div id="footer-message">This document was generated by<i>Takashi Kato</i> with Sagittarius gendoc. </div>
    <div id="footer-date">Generated date: <i>2017-04-21T21:14:43+0200</i></div>
  </div>
</html>