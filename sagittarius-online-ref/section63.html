<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-eqiv="Content-Type" content="text/html; charset=utf-8">
    <link rel="stylesheet" type="text/css" href="../lib/style.css">
    <title>Sagittarius Users' Reference</title>
  </head>
  <div class="prev-next">
    <a class="prev" href="section62.html">(sagittarius control) - control library</a>
    <a class="top" href="../sagittarius-online-ref.html">Top</a>
    <a class="next" href="section64.html">(sagittarius filewatch) - Monitoring filesystem</a>
  </div>
  <section class="subsection"><h3 class="subsection">
    <a class="section.anchor" name="lib.sagittarius.ffi"><span class="section-number">6.3</span>(sagittarius ffi) - Foreign Function Interface</a>
  </h3>
<p /><div class="define">
    <span class="define-category">Library</span>
    <a name="(sagittarius ffi)1136">
      <span class="name" name="(sagittarius ffi)">(sagittarius ffi)</span>
    </a>
  </div>
<div class="desc">This library provides FFI (Foreign Function Interface) procedures. The
library is constructed on 
<a href="http://sourceware.org/libffi/">libffi</a>.
<p />This library makes user to be able to re-use existing useful C library. However
it might cause SEGV or unexpected behaviours. It is users responsibility to
avoid those errors.
<p />Following is the simple example to use;
<div class="codeblock-box">
    <pre class="codeblock">;; Scheme file
;; load shared library (on Windows the extension might be '.dll')
;; On Unix like environment, the shared library must be full path or
;; located in the same directory as the script.
;; On Windows it can be on PATH environment variable as well.
(define so-library (open-shared-library "my-quick-sort.so"))
(define quick-sort 
  (c-function so-library ;; shared library
              void       ;; return type
              quicksort  ;; exported symbol
              ;; argument types
              ;; if you need pass a callback procedure, 'callback' mark needs to
              ;; be passed to the arguments list
              (void* size_t size_t callback)))

(let ((array (u8-list-&gt;bytevector '(9 3 7 5 2 6 1 4 8)))
      ;; callback procedure
      (compare (c-callback int           ;; return type
                           (void* void*) ;; argument types
                           (lambda (a b)
                             (- (pointer-ref-c-uint8 x 0)
                                (pointer-ref-c-uint8 y 0))))))
  ;; call c function. all loaded c functions are treated the same as
  ;; usual procedures.
  (quick-sort array (bytevector-length array) 1 compare)
  ;; release callback procedure.
  ;; NOTE: callback won't be GCed so users need to release it manually
  (free-c-callback compare)
  array)

;; Close shared library.
(close-shared-library so-library)

;; End of Scheme file

/* C file, must be compiled as a shared library and named 'my-quick-sort.so' */
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#ifdef _MSC_VER
# define EXPORT __declspec(dllexport)
#else
# define EXPORT
#endif

static void quicksort_(uintptr_t base,const size_t num,const size_t size,
		       void *temp,int (*compare)(const void *,const void *))
{
  size_t pivot = 0,first2last = 0,last2first = num-1;
  while(pivot+1 != num &amp;&amp; !compare(base+size*pivot,base+size*(pivot+1))){
    pivot++;
  }
  if(pivot+1 == num){
    return;
  }
  if(0 &gt; compare(base+size*pivot,base+size*(pivot+1))){
    pivot++;
  }
  while(first2last &lt; last2first){
    while(0 &lt; compare(base+size*pivot,base+size*first2last)
	  &amp;&amp; first2last != num-1){
      first2last++;
    }
    while(0 &gt;= compare(base+size*pivot,base+size*last2first)
	  &amp;&amp; last2first){
      last2first--;
    }
    if(first2last &lt; last2first){
      if(pivot == first2last || pivot == last2first){
	pivot = pivot^last2first^first2last;
      }
      memcpy(temp,base+size*first2last,size);
      memcpy(base+size*first2last,base+size*last2first,size);
      memcpy(base+size*last2first,temp,size);
    }
  }
  quicksort_(base,first2last,size,temp,compare);
  quicksort_(base+size*first2last,num-first2last,size,temp,compare);
}

EXPORT int quicksort(void *base, const size_t num, const size_t size,
	      int (*compare)(const void *, const void *))
{
  void *temp = malloc(size);
  if(!temp){
    return -1;
  }
  quicksort_((uintptr_t)base,num,size,temp,compare);
  free(temp);
  return 0;
}

</pre>
    <span class="codeblock-arrow">=&gt;</span>
    <span class="codeblock-result">#vu8(1 2 3 4 5 6 7 8 9)</span>
  </div>
The document describes higher APIs to lower APIs.
<p /></div>
<p /><section class="subsubsection"><h4 class="subsubsection">
    <a class="section.anchor" name="G1137"><span class="section-number">6.3.1</span>Shared library  operations</a>
  </h4>
<p /><div class="define"><span class="define-category">Function</span><a name="open-shared-library1138">
    <span class="name" name="open-shared-library">open-shared-library</span>
  </a> <span class="args">file :optional (raise #f)</span></div>
<div class="desc"><var>file</var> must be a string.
<p />Opens given <var>file</var> shared library and returns its pointer.
<p />The internal process of <code>open-shared-library</code> is depending on the
platform, for example if your platform is POSIX envirionment then it will use
<code>dlopen</code>. So the resolving the <var>file</var> depends on it. If you know the
absolute path of the shared library, then it's always better to use it.
<p />If then internal process of the procedure failed and <var>raise</var> is #f then it
returns NULL pointer, if <var>raise</var> is #t then it raises an error.
</div>
<p /><div class="define"><span class="define-category">Function</span><a name="close-shared-library1139">
    <span class="name" name="close-shared-library">close-shared-library</span>
  </a> <span class="args">pointer</span></div>
<div class="desc">Closes given shared library pointer and returns unspecified value.
<p />If the given pointer does not indicate proper shared library, the behaviour
is platform dependent. It might cause SEGV.
</div>
<p /><div class="define">
    <span class="define-category">Function</span>
    <a name="shared-object-suffix1140">
      <span class="name" name="shared-object-suffix">shared-object-suffix</span>
    </a>
  </div>
<div class="desc">Returns platform specific shared library extension as a string value.
eg. <code>".dll"</code> in Windows, <code>".so"</code> in Linux or Unix.
</div>
<p /></section><section class="subsubsection"><h4 class="subsubsection">
    <a class="section.anchor" name="G1141"><span class="section-number">6.3.2</span>Creating C functions</a>
  </h4>
<p />This section describes more details to create a corresponding C functions.
<p /><div class="define"><span class="define-category">Macro</span><a name="c-function1142">
    <span class="name" name="c-function">c-function</span>
  </a>
 <span class="args">shared-library return-type name (argument-types ...)</span></div>
<div class="desc">Creates a c-function object and returns a Scheme procedure.
<p /><var>shared-library</var> must be opened shared-library.
<p /><var>return-type</var> must be one of the followings;
<pre class="codeblock">  void 
  bool  char
  short int long long-long
  unsigned-short unsigned-int unsigned-long unsigned-long-long
  intptr_t uintptr_t
  float double
  void* char* wchar_t*
  int8_t  int16_t  int32_t  int64_t
  uint8_t uint16_t uint32_t uint64_t
</pre>
The return value will be converted corresponding Scheme value. Following
describes the conversion;
<div class="dl-list-wrapper">
    <dl class="dl-list">
      <dt class="dl-item-title">
        <code>bool</code>
      </dt>
      <dd class="dl-item-desc">Scheme boolean</dd>
      <dt class="dl-item-title">
        <code>char*</code>
      </dt>
      <dd class="dl-item-desc">Scheme string from UTF-8</dd>
      <dt class="dl-item-title">
        <code>wchar_t*</code>
      </dt>
      <dd class="dl-item-desc">Scheme string from UTF-16 (Windows) or UTF-32. </dd>
      <dt class="dl-item-title">
        <code>char</code>
      </dt>
      <dt class="dl-item-title">
        <code>short int long long-long</code>
      </dt>
      <dt class="dl-item-title">
        <code>unsigned-short unsigned-int unsigned-long unsigned-long-long</code>
      </dt>
      <dt class="dl-item-title">
        <code>intptr_t uintptr_t</code>
      </dt>
      <dt class="dl-item-title">
        <code>int8_t  int16_t  int32_t  int64_t</code>
      </dt>
      <dt class="dl-item-title">
        <code>uint8_t uint16_t uint32_t uint64_t</code>
      </dt>
      <dd class="dl-item-desc">Scheme integer</dd>
      <dt class="dl-item-title">
        <code>float double</code>
      </dt>
      <dd class="dl-item-desc">Scheme flonum</dd>
      <dt class="dl-item-title">
        <code>void*</code>
      </dt>
      <dd class="dl-item-desc">Scheme FFI pointer type</dd>
    </dl>
  </div>
NOTE: <code>char</code> returns a Scheme integer not Scheme character.
<p /><var>name</var> must be a symbol indicating a exported C function name.
<p /><var>argument-types</var> must be zero or more followings;
<pre class="codeblock">  bool
  char short int long long-long
  unsigned-short unsigned-int unsigned-long unsigned-long-long
  size_t
  void* char* wchar_t*
  float double
  int8_t  int16_t  int32_t  int64_t
  uint8_t uint16_t uint32_t uint64_t
  callback
  ___
</pre>
When the C function is called, given Scheme arguments will be converted to
corresponding C types. Following describes the conversion;
<div class="dl-list-wrapper">
    <dl class="dl-list">
      <dt class="dl-item-title">
        <code>bool</code>
      </dt>
      <dd class="dl-item-desc">Scheme boolean to C 0 (#f) or 1 (#t).</dd>
      <dt class="dl-item-title">
        <code>char short int long long-long unsigned-short</code>
      </dt>
      <dt class="dl-item-title">
        <code>int8_t int16_t int32_t uint8_t uint16_t</code>
      </dt>
      <dd class="dl-item-desc">Scheme integer to C signed long int</dd>
      <dt class="dl-item-title">
        <code>unsigned-int unsigned-long uint32_t size_t</code>
      </dt>
      <dd class="dl-item-desc">  Scheme integer to C unsigned long int</dd>
      <dt class="dl-item-title">
        <code>int64_t long-long</code>
      </dt>
      <dd class="dl-item-desc">Scheme integer to C int64_t</dd>
      <dt class="dl-item-title">
        <code>uint64_t unsigned-long-long</code>
      </dt>
      <dd class="dl-item-desc">Scheme integer to C uint64_t</dd>
      <dt class="dl-item-title">
        <code>float</code>
      </dt>
      <dd class="dl-item-desc">Scheme flonum to C float</dd>
      <dt class="dl-item-title">
        <code>double</code>
      </dt>
      <dd class="dl-item-desc">Scheme flonum to C double</dd>
      <dt class="dl-item-title">
        <code>void* char*</code>
      </dt>
      <dd class="dl-item-desc">  <code>void*</code> and <code>char*</code> are actually treated the same, internally.
  The conversion will be like this;
  <div class="dl-list-wrapper">
        <dl class="dl-list">
          <dt class="dl-item-title">Scheme string</dt>
          <dd class="dl-item-desc">Converts to UTF-8 C char*</dd>
          <dt class="dl-item-title">Scheme bytevector</dt>
          <dd class="dl-item-desc">Convert to C char*</dd>
          <dt class="dl-item-title">Scheme FFI pointer</dt>
          <dd class="dl-item-desc">Convert to C void*</dd>
        </dl>
      </div>
</dd>
      <dt class="dl-item-title">
        <code>wchar_t*</code>
      </dt>
      <dd class="dl-item-desc">  Wide character string conversion only happens when the given argument was
  Scheme string and depends on the platform. On Windows, more specifically 
  size of wchar_t is 2 platform, it converts to UTF-16 string without BOM.
  On other platform, size of wchar_t is 4 platform, it converts to UTF-32.
  Both case detects endianness automatically.
<p />  If the given argument was bytevector, it won't convert. This case is useful
  when users need to pass buffer to a C-function.
</dd>
      <dt class="dl-item-title">
        <code>callback</code>
      </dt>
      <dd class="dl-item-desc">Scheme FFI callback to C void*</dd>
    </dl>
  </div>
Note: passing Scheme string needs to be careful when users want to use it
as a buffer. It doesn't work like it. Use bytevector or FFI pointer object
for that purpose.
<p /><code>___</code> is for variable length argument and it must be the last position
of the argument type list, otherwise it raises an error.
<p /></div>
<p /><div class="define"><span class="define-category">Function</span><a name="make-c-function1143">
    <span class="name" name="make-c-function">make-c-function</span>
  </a>
 <span class="args">shared-library return-type name argument-types</span></div>
<div class="desc">Creates C function. This procedure is underlying procedure for
<code>c-function</code> macro. The arguments are the same as <code>c-function</code>,
only <var>argument-types</var> must be a list of types.
</div>
<p /><div class="define"><span class="define-category">Macro</span><a name="address1144">
    <span class="name" name="address">address</span>
  </a> <span class="args">pointer</span></div>
<div class="define"><span class="define-category">Macro</span><a name="address1145">
    <span class="name" name="address">address</span>
  </a> <span class="args">pointer offset</span></div>
<div class="desc">Convenient macro for address passing.
<p />When you need to pass an address of a pointer to C function, you can write like
this;
<pre class="snipet">(c-func (address <var>pointer</var>))</pre>
<p />This is equivalent of following C code;
<pre class="snipet">c_func(&amp;pointer)</pre>
<p /><var>pointer</var> can be a pointer object or a bytevector.
<p />If the second form is used, then the passing address is offset of <var>offset</var>.
It is user's responsibility to make sure the given <var>pointer</var> has enough
space when <var>offset</var> is passed. If the <var>pointer</var> is a bytevector and
<var>offset</var> is more than the bytevector size, then an error is signaled.
</div>
<p /><div class="define"><span class="define-category">Macro</span><a name="c-callback1146">
    <span class="name" name="c-callback">c-callback</span>
  </a>
 <span class="args">return-type (argument-types ...) proc</span></div>
<div class="desc">Creates a C callback.
<p /><var>return-type</var> must be a symbol and the same as <code>c-function</code>'s
<var>return-type</var>.
<p /><var>argument-types</var> must be zero or following;
<pre class="codeblock">  bool
  char short int long long-long intptr_t
  unsigned-char unsigned-short unsigned-int unsigned-long-long uintptr_t
  int8_t int16_t int32_t int64_t
  uint8_t uint16_t uint32_t int64_t
  float double
  size_t
  void*
</pre>
The conversion of C to Scheme is the same as <code>c-function</code>'s
<var>return-type</var>.
<p />NOTE: if the content of <code>void*</code> won't be copied, thus if you modify it in
the callback procedure, corresponding C function will get affected.
<p />NOTE: callback doesn't support <code>char*</code> nor <code>wchar_t*</code>. It is because
the conversion loses original pointer address and you might not want it. So
it is users responsibility to handle it.
<p /><var>proc</var> must be a procedure takes the same number of arguments as
<var>argument-types</var> list.
<p />Created callbacks are stored intarnal static storage to avoid to get GCed.
This is because C functions which accept callback may hold the given callback
in their storage which could be outside of Sagittarius GC root. So it is
users' responsibility to release created callback to avoid memory leak. To
release callbacks, you need to use <coe>free-c-callback</coe>.
</div>
<p /><div class="define"><span class="define-category">Macro</span><a name="make-c-callback1147">
    <span class="name" name="make-c-callback">make-c-callback</span>
  </a>
 <span class="args">return-type argument-types proc</span></div>
<div class="desc">Creates C callback. This procedure is underlying procedure for
<code>c-callback</code> macro. The arguments are the same as <code>c-callback</code>,
only <var>argument-types</var> must be a list of types.
</div>
<p /><div class="define"><span class="define-category">Function</span><a name="free-c-callback1148">
    <span class="name" name="free-c-callback">free-c-callback</span>
  </a> <span class="args">callback</span></div>
<div class="desc">Release <var>callback</var>.</div>
<p /></section><section class="subsubsection"><h4 class="subsubsection">
    <a class="section.anchor" name="G1149"><span class="section-number">6.3.3</span>Pointer operations</a>
  </h4>
<p />Using C functions, users can not avoid to use raw pointers. This section
describes how to create or convert a pointer.
<p /><div class="define"><span class="define-category">Function</span><a name="pointer?1150">
    <span class="name" name="pointer?">pointer?</span>
  </a> <span class="args">obj</span></div>
<div class="desc">Returns #t if <var>obj</var> is FFI pointer object, otherwise #f.</div>
<p /><div class="define"><span class="define-category">Function</span><a name="integer-&gt;pointer1151">
    <span class="name" name="integer-&gt;pointer">integer-&gt;pointer</span>
  </a> <span class="args">integer</span></div>
<div class="desc">Converts given <var>integer</var> to pointer object.
<p />To represents NULL pointer, you can write like this;
<div class="snipet-box">
    <pre class="snipet">(integer-&gt;pointer 0)</pre>
    <span class="snipet-arrow">=&gt;</span>
    <span class="snipet-result">#&lt;pointer 0x0&gt;</span>
  </div>
</div>
<p /><div class="define"><span class="define-category">Function</span><a name="pointer-&gt;integer1152">
    <span class="name" name="pointer-&gt;integer">pointer-&gt;integer</span>
  </a> <span class="args">pointer :optional bits</span></div>
<div class="define"><span class="define-category">Function</span><a name="pointer-&gt;uinteger1153">
    <span class="name" name="pointer-&gt;uinteger">pointer-&gt;uinteger</span>
  </a> <span class="args">pointer :optional bits</span></div>
<div class="desc">Converts given <var>pointer</var> to integer/uinteger, respectively.
<p />The optional argument <var>bits</var> must be an exact integer range of fixnum.
<p />If the optional argument <var>bits</var> is specified, then the procedure mask
the pointer value. If the <var>bits</var> is negative or more than pointer size
bits then it returns non masked value.
<p />This is useful when C procedure sets the pointer value however it only sets
a half of bits and returning value is needed only a half of bits. 
For example, a C procedure takes 2 arguments, one is buffer pointer the
other one is buffer size pointer. When buffer size is -1 then it allocates 
sufficient buffer and sets buffer size pointer the allocated size. In this
case. In this case, if you are using 64 bit environment and buffer size
pointer is 32 bit value's pointer returning value's upper 32 bit would be
0xFFFFFFFF. If the optional argument is specified to 32 then the procedure
only returns lower 32 bit value.
</div>
<p /><div class="define"><span class="define-category">Function</span><a name="pointer-&gt;string1154">
    <span class="name" name="pointer-&gt;string">pointer-&gt;string</span>
  </a>
 <span class="args">pointer :optional (transcoder (native-transcoder))</span></div>
<div class="desc">Converts given <var>pointer</var> to Scheme string.
<p />The given <var>pointer</var> must be terminated by 0 otherwise it won't stop until
it reaches 0.
<p />If NULL pointer is given, it raises <code>&amp;assertion</code>.
</div>
<p /><div class="define"><span class="define-category">Function</span><a name="pointer-&gt;bytevector1155">
    <span class="name" name="pointer-&gt;bytevector">pointer-&gt;bytevector</span>
  </a>
 <span class="args">pointer size :optional (offset 0) (shared #t)</span></div>
<div class="desc"><var>Size</var> must be an exact integer.
<p />Converts given <var>pointer</var> to Scheme bytevector from given <var>offset</var>. 
<p />If optional argument <var>shared</var> is #f, then the content of pointer won't
be shared between pointer and bytevector. Default value is #t, thus if the
given <var>pointer</var> is modified, then the created bytevector gets affected.
<p />If NULL pointer is given, it raises <code>&amp;assertion</code>.
</div>
<p /><div class="define"><span class="define-category">Function</span><a name="bytevector-&gt;pointer1156">
    <span class="name" name="bytevector-&gt;pointer">bytevector-&gt;pointer</span>
  </a>
 <span class="args">bv :optional (offset 0) (shared #t)</span></div>
<div class="desc">Converts given <var>bytevector</var> to pointer from given <var>offset</var>. 
<p />If optional argument <var>shared</var> is #f, then the content of bytevector won't
be shared between bytevector and pointer. Default value is #t, thus if the
given <var>bv</var> is modified, then the created pointer gets affected.
<p />If NULL pointer is given, it raises <code>&amp;assertion</code>.
</div>
<p />
<div class="define"><span class="define-category">Function</span><a name="object-&gt;pointer1157">
    <span class="name" name="object-&gt;pointer">object-&gt;pointer</span>
  </a> <span class="args">obj</span></div>
<div class="define"><span class="define-category">Function</span><a name="pointer-&gt;object1158">
    <span class="name" name="pointer-&gt;object">pointer-&gt;object</span>
  </a> <span class="args">pointer</span></div>
<div class="desc">CAUTION: These operations are really dangerous especially
<code>pointer-&gt;object</code>.
<p />Converts Scheme object to pointer and pointer to Scheme object respectively.
The operations are useful to pass Scheme object to callbacks and restore
it.
</div>
<p /><div class="define"><span class="define-category">Function</span><a name="deref1159">
    <span class="name" name="deref">deref</span>
  </a> <span class="args">pointer offset</span></div>
<div class="desc"><var>offset</var> must be a fixnum.
<p />Returns a pointer offset <var>offset</var> of given <var>pointer</var>. The same as
following C code;
<pre class="codeblock">void* deref(void **pointer, int offset) {
  return pointer[offset]; 
}
</pre>
If NULL pointer is given, it raises <code>&amp;assertion</code>.
</div>
<p /><div class="define"><span class="define-category">Function</span><a name="pointer-address1160">
    <span class="name" name="pointer-address">pointer-address</span>
  </a> <span class="args">pointer :optional offset</span></div>
<div class="desc">Returns an address of given <var>pointer</var>.
<p />If optional argument <var>offset</var> is given, then the returning address of
<var>pointer</var> is the offset of given <var>offset</var>.
<p />NOTE: This creates a newly allocated Scheme FFI pointer object.
<p />NOTE: If the returned value is modified then given <var>pointer</var> will be
affected.
</div>
<p /><div class="define"><span class="define-category">Function</span><a name="allocate-pointer1161">
    <span class="name" name="allocate-pointer">allocate-pointer</span>
  </a> <span class="args">size :optional (fill 0)</span></div>
<div class="desc"><var>size</var> must be a fixnum.
<p />Allocates a <var>size</var> of byte memory and returns an pointer object.
<p />If optional argument <var>fill</var> is given, it must be a fixnum, then the
procedure fill the given <var>fill</var> into the allocated memory using
<code>memset(3)</code>. 
<p />NOTE: the <var>fill</var> will be converted to an unsigned char by the 
<code>memset(3)</code>.
<p />The allocated memory will be GCed.
</div>
<p /><div class="define"><span class="define-category">Function</span><a name="c-malloc1162">
    <span class="name" name="c-malloc">c-malloc</span>
  </a> <span class="args">size</span></div>
<div class="desc"><var>size</var> must be a fixnum.
<p />Allocates a <var>size</var> of byte memory and returns an pointer object using 
C's <code>malloc</code>.
<p />The allocated memory won't be GCed. So releasing the memory is users'
responsibility.
</div>
<p /><div class="define"><span class="define-category">Function</span><a name="c-free1163">
    <span class="name" name="c-free">c-free</span>
  </a> <span class="args">pointer</span></div>
<div class="desc"><var>pointer</var> must be a pointer created by <var>c-malloc</var>.
<p />Release the <var>pointer</var>.
<p />The procedure won't check if the pointer is allocated by <var>c-malloc</var> or not.
And the behaviour when GCable pointer is passed is undefined.
</div>
<p /><div class="define">
    <span class="define-category">Variable</span>
    <a name="null-pointer1164">
      <span class="name" name="null-pointer">null-pointer</span>
    </a>
  </div>
<div class="desc">A pointer represents NULL.
<p />This value is not a constant and if you modify this by using <code>address</code>,
you might break some codes.
</div>
<p /><div class="define"><span class="define-category">Function</span><a name="null-pointer?1165">
    <span class="name" name="null-pointer?">null-pointer?</span>
  </a> <span class="args">obj</span></div>
<div class="desc">Returns #t when <var>obj</var> is a pointer representing NULL otherwise #f.</div>
<p /><div class="define">
    <span class="define-category">Function</span>
    <a name="empty-pointer1166">
      <span class="name" name="empty-pointer">empty-pointer</span>
    </a>
  </div>
<div class="desc">Creates a NULL pointer. This is for convenience.</div>
<p /><div class="define"><span class="define-category">Function</span><a name="pointer-ref-c-type1167">
    <span class="name" name="pointer-ref-c-type">pointer-ref-c-<var>type</var></span>
  </a> <span class="args">pointer offset</span></div>
<div class="desc"><var>offset</var> must be a fixnum.
<p />Returns an integer value of offset <var>offset</var> of <var>pointer</var> depending
on the <var>type</var>.
<p />Following <var>type</var> are supported;
<code>  int8  int16  int32  int64
  uint8 uint16 uint32 uint64
  char wchar short  int long long-long
  unsigned-char unsigned-short unsigned-int unsigned-long unsigned-long-long
  intptr uintptr
  float double
  pointer
</code>
NOTE: if the <var>type</var> is <code>flonum</code> or <code>double</code>, then it returns
Scheme flonum
<p />NOTE: if the <var>type</var> is <code>pointer</code>, then it returns Scheme FFI pointer.
</div>
<p /><div class="define"><span class="define-category">Function</span><a name="pointer-set-c-type!1168">
    <span class="name" name="pointer-set-c-type!">pointer-set-c-<var>type</var>!</span>
  </a> <span class="args">pointer offset value</span></div>
<div class="desc"><var>offset</var> must be a fixnum.
<p />Sets <var>value</var> to offset <var>offset</var> of <var>pointer</var>. Supporting <var>type</var>s
are the same as <code>pointer-ref-c-<var>type</var></code>
<p />The type conversion is the same as <code>c-function</code>'s <var>return-type</var>.
<p />There is no direct procedures to handle C arrays. Following is an example
of how to handle array of pointers;
<pre class="codeblock">(import (rnrs) (sagittarius ffi))

(define (string-vector-&gt;c-array sv)
  (let ((c-array (allocate-pointer (* (vector-length sv) size-of-void*))))
    (do ((i 0 (+ i 1)))
        ((= i (vector-length sv)) c-array)
      ;; pointer-set-c-pointer! handles Scheme string (converts to UTF-8)
      ;; If you need other encoding, then you need to write other conversion
      ;; procedure.
      (pointer-set-c-pointer! c-array (* i size-of-void*) (vector-ref sv i)))))

;; how to use
(let ((p (string-vector-&gt;c-array #("abc" "def" "ghijklmn"))))
  (do ((i 0 (+ i 1)))
      ((= i 3))
    ;; deref handles pointer offset.
    ;; it can be also (pointer-ref-c-pointer p (* i size-of-void*))
    (print (pointer-&gt;string (deref p i)))))
</pre>
<p />Following is an example for Scheme string to UTF-16 bytevector;
<pre class="codeblock">(import (rnrs) (sagittarius ffi))
;; Converts to UTF16 big endian (on little endian environment)
(define (string-&gt;c-string s)
  (let* ((bv (string-&gt;utf16 s (endianness big)))
         ;; add extra 2 bytes for null terminated string
         (p  (allocate-pointer (+ (bytevector-length bv) 2))))
    (do ((i 0 (+ i 2)))
        ((= i (bytevector-length bv)) p)
      ;; pointer-set-c-uint16! uses native endianness to set the value
      ;; so this is platform dependent code.
      (pointer-set-c-uint16! p i 
        (bytevector-u16-ref bv i (endianness little))))))
</pre>
<p /></div>
<p /><div class="define"><span class="define-category">Function</span><a name="set-pointer-value!1169">
    <span class="name" name="set-pointer-value!">set-pointer-value!</span>
  </a> <span class="args">pointer value</span></div>
<div class="desc"><var>value</var> must be exact integer up to <code>size-of-void*</code> bytes.
<p />Sets the pointer value. This is useful to reuse the existing pointer object.
<p />CAUTION: this operation is really dangerous so be aware of it!
</div>
<p /></section><section class="subsubsection"><h4 class="subsubsection">
    <a class="section.anchor" name="G1170"><span class="section-number">6.3.4</span>C struct operations</a>
  </h4>
<p />C's struct is mere memory chunk so it is possible to access its member directly,
if you know exact offset of it. However it is convenient if you can operate 
similar structure. This section describes how to define C structure in Scheme
world.
<p /><div class="define"><span class="define-category">Macro</span><a name="define-c-struct1171">
    <span class="name" name="define-c-struct">define-c-struct</span>
  </a> <span class="args">name clauses ...</span></div>
<div class="desc">Defines C structure.
<p /><var>clauses</var> must be following form;
<pre class="codeblock">(<var>type</var> <var>name</var>)
(<var>type</var> <code>array</code> <var>size</var> <var>name</var>)
(<code>struct</code> <var>struct-name</var> <var>name</var>)
(<code>bit-field</code> <var>type</var> (<var>name</var> <var>bit</var>) ...)
(<code>bit-field</code> (<var>type</var> <var>endian</var>) (<var>name</var> <var>bit</var>) ...)
</pre>
<var>name</var> must be a symbol.
<p />The first form is the simple C type form. <var>type</var> must be a symbol and the
same as one of the <code>c-function</code>'s <var>return-types</var> or <code>callback</code>.
Following describes the concrete example and the equivalent C structure:
<pre class="codeblock">(define-c-struct st
  (int foo)
  (callback fn))
#|
struct st
{
  int foo;
  void* fn; /* function pointer */
};
|#
</pre>
<p />The second form is defining C <var>type</var> array with <var>size</var>.
Following describes the concrete example and the equivalent C structure:
<pre class="codeblock">(define-c-struct st
  (int array 10 foo))
#|
struct st
{
  int foo[10];
};
|#
</pre>
<p />The third form is defining internal structure.
Following describes the concrete example and the equivalent C structure:
<pre class="codeblock">(define-c-struct st1
  (int array 10 foo))
(define-c-struct st2
  (struct st1 st)
  (int bar))
#|
struct st1
{
  int foo[10];
};
struct st2
{
  struct st1 st;
  int bar;
};
|#
</pre>
So far, we don't support direct internal structure so users always need to
extract internal structures.
<p />The forth and fifth forms are bit fields. <var>type</var> must be an integer
type such as <code>unsigned-int</code>. If the given <var>type</var> is not an integer,
then <code>&amp;assertion</code> is raised.
<p />Following describes the concrete example and the equivalent C structure:
<pre class="codeblock">(define-c-struct st1
  (bit-field unsigned-int (a 10) (b 20)))
#|
struct st1
{
  unsigned int a : 10;
  unsigned int b : 20;
};
|#
</pre>
If the fifth form is used, then <var>endian</var> must be an identifier which has
valid name for <code>endianness</code> macro. Then the created structure packs
the value according to the given <var>endian</var>.
<p />If the total amount of bits is greater than given <var>type</var>, then 
<code>&amp;assertion</code> is raised.
<p />NOTE: Even though, this can accept signed integer the returning value would
not be signed. It is safe to specify unsigned type.
<p />
The macro also defines accessors for the c-struct. Following naming rules are
applied;
<p /><ul class="itemlist"><li class="itemlist-item">For getter: <var>name</var>-<var>member-name</var>-ref</li>
<li class="itemlist-item">For setter: <var>name</var>-<var>member-name</var>-set!</li>
</ul>
<p /></div>
<p /><div class="define"><span class="define-category">Function</span><a name="size-of-c-struct1172">
    <span class="name" name="size-of-c-struct">size-of-c-struct</span>
  </a> <span class="args">struct</span></div>
<div class="desc"><var>struct</var> must be a C structure defined by <code>define-c-struct</code>.
<p />Returns the size of given <var>struct</var>.
</div>
<p /><div class="define"><span class="define-category">Function</span><a name="allocate-c-struct1173">
    <span class="name" name="allocate-c-struct">allocate-c-struct</span>
  </a> <span class="args">struct</span></div>
<div class="desc">Allocates memory for <var>struct</var> and returns a pointer.</div>
<p /><div class="define"><span class="define-category">Function</span><a name="struct-name-member-name-ref1174">
    <span class="name" name="struct-name-member-name-ref"><var>struct-name</var>-<var>member-name</var>-ref</span>
  </a>
 <span class="args">struct-pointer inner-member-names ...</span></div>
<div class="define"><span class="define-category">Function</span><a name="struct-name-member-name-set!1175">
    <span class="name" name="struct-name-member-name-set!"><var>struct-name</var>-<var>member-name</var>-set!</span>
  </a>
 <span class="args">struct-pointer value inner-member-names ...</span></div>
<div class="desc">A getter/setter of <var>struct-name</var> c-struct.
<p />This is automatically defined by <code>define-c-struct</code> macro.
<p />The optional argument <var>inner-member-names</var> can be passed to get inner
struct values.
<p />Following describes how it works.
<pre class="codeblock">(define-c-struct in
  (int  i)
  (char c))
(define-c-struct out
  (int  i)
  (struct in in0))

(define out (allocate-c-struct out))
(out-i-set! out 100 'i)   ;; -&gt; unspecified
(out-in0-set! out 200 'i) ;; -&gt; unspecified
(out-i-ref out)           ;; -&gt; 100
(out-in0-ref out 'i)      ;; -&gt; 200
(out-in0-ref out)         ;; -&gt; pointer object (indicating the inner struct address)
</pre>
</div>
<p /><section class="sub-section"><h5 class="sub-section">
    <a class="section.anchor" name="G1176"><span class="section-number">6.3.4.1</span>Low level C struct accessors</a>
  </h5>
<p /><div class="define"><span class="define-category">Function</span><a name="c-struct-ref1177">
    <span class="name" name="c-struct-ref">c-struct-ref</span>
  </a> <span class="args">pointer struct name</span></div>
<div class="desc"><var>struct</var> must be a C structure defined with <code>define-c-struct</code>.
<var>name</var> must be a symbol and <var>struct</var> has the same member.
<var>pointer</var> should be a pointer allocated by <code>allocate-c-struct</code> with
<var>struct</var>.
<p />Returns a member <var>name</var>'s value of <var>struct</var> from <var>pointer</var>.
</div>
<p /><div class="define"><span class="define-category">Function</span><a name="c-struct-set!1178">
    <span class="name" name="c-struct-set!">c-struct-set!</span>
  </a> <span class="args">pointer struct name value</span></div>
<div class="desc"><var>struct</var> must be a C structure defined with <code>define-c-struct</code>.
<var>name</var> must be a symbol and <var>struct</var> has the same member.
<var>pointer</var> should be a pointer allocated by <code>allocate-c-struct</code> with
<var>struct</var>.
<p />Sets <var>value</var> to <var>pointer</var> offset of member <var>name</var> of <var>struct</var>.
</div>
<p /></section></section><section class="subsubsection"><h4 class="subsubsection">
    <a class="section.anchor" name="G1179"><span class="section-number">6.3.5</span>Typedef operations</a>
  </h4>
<p /><div class="define"><span class="define-category">Macro</span><a name="define-c-typedef1180">
    <span class="name" name="define-c-typedef">define-c-typedef</span>
  </a> <span class="args">original new-names ...</span></div>
<div class="desc">Convenient macro.
<p />Defines other name of <var>original</var> with <var>new-names</var>.
<p /><var>new-names</var> must be following forms;
<pre class="codeblock">()
((<code>*</code> <var>new-p</var>) <var>rest</var> ...)
((<code>s*</code> <var>new-sp</var>) <var>rest</var> ...)
(<var>new</var> <var>rest</var> ...)
</pre>
The first for defines nothing.
<p />If the rest of form is used and <var>rest</var> is not null, then it will recursively
define.
<p />The second form's <code>*</code> defines <var>new-p</var> as <code>void*</code>.
<p />The third form's <code>s*</code> defines <var>new-sp</var> as <code>char*</code>.
<p />The forth form defines <var>new</var> as <var>original</var>.
<p />Following example describes how to will be expanded approximately.
<pre class="codeblock">(define-c-typedef char (* char_ptr) byte (s* string))

=&gt; 

(begin
  (define char_ptr void*)
  (define byte char)
  (define string char*)
)
</pre>
</div>
<p /></section><section class="subsubsection"><h4 class="subsubsection">
    <a class="section.anchor" name="G1181"><span class="section-number">6.3.6</span>Sizes and aligns</a>
  </h4>
<p /><div class="define">
    <span class="define-category">Constant</span>
    <a name="size-of-type1182">
      <span class="name" name="size-of-type">size-of-<var>type</var></span>
    </a>
  </div>
<div class="define">
    <span class="define-category">Constant</span>
    <a name="align-of-type1183">
      <span class="name" name="align-of-type">align-of-<var>type</var></span>
    </a>
  </div>
<div class="desc">a size or align of <var>type</var>, respectively.
<p />Following types are supported;
<pre class="codeblock">  bool char
  short int long long-long
  unsigned-short unsigned-int unsigned-long unsigned-long-long
  intptr_t uintptr_t size_t
  float double
  int8_t  int16_t  int32_t  int64_t
  uint8_t uint16_t uint32_t uint64_t
  void*
</pre>
The values are platform dependent.
</div>
<p /></section><section class="subsubsection"><h4 class="subsubsection">
    <a class="section.anchor" name="G1184"><span class="section-number">6.3.7</span>Finalizer operations</a>
  </h4>
<p />Some of C resource must be released but if you can not decide or do not want to
restrict when, then you can release it at GC time.
<p />NOTE: GC might not happen if your script is very short, so it is better not to
relay these procedures too much.
<p /><div class="define"><span class="define-category">Function</span><a name="register-ffi-finalizer1185">
    <span class="name" name="register-ffi-finalizer">register-ffi-finalizer</span>
  </a> <span class="args">pointer proc</span></div>
<div class="desc"><var>pointer</var> must be a pointer allocated with GCable memory.
<p /><var>proc</var> must be a procedure and accepts one argument. The argument will be
the <var>pointer</var>.
<p />Register <var>proc</var> as <var>pointer</var>'s finalizer and returns <var>pointer</var>.
</div>
<div class="define"><span class="define-category">Function</span><a name="unregister-ffi-finalizer1186">
    <span class="name" name="unregister-ffi-finalizer">unregister-ffi-finalizer</span>
  </a> <span class="args">pointer</span></div>
<div class="desc"><var>pointer</var> must be a pointer allocated with GCable memory.
<p />Remove finalizer form <var>pointer</var> and returns <var>pointer</var>.
</div>
</section></section>
  <div class="prev-next">
    <a class="prev" href="section62.html">(sagittarius control) - control library</a>
    <a class="top" href="../sagittarius-online-ref.html">Top</a>
    <a class="next" href="section64.html">(sagittarius filewatch) - Monitoring filesystem</a>
  </div>
  <hr>
  <div id="document-footer">
    <div id="footer-message">This document was generated by<i>Takashi Kato</i> with Sagittarius gendoc. </div>
    <div id="footer-date">Generated date: <i>2018-02-17T20:49:47Z</i></div>
  </div>
</html>